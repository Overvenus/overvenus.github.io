<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Neil</title>
    <link>http://neilsh.me/</link>
    <description>Recent content on Neil</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Wed, 16 Mar 2016 21:49:02 +0800</lastBuildDate>
    <atom:link href="http://neilsh.me/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>理解 Goroutine &amp; Gosched</title>
      <link>http://neilsh.me/2016/03/16/understanding-of-runtime-goroutine/</link>
      <pubDate>Wed, 16 Mar 2016 21:49:02 +0800</pubDate>
      
      <guid>http://neilsh.me/2016/03/16/understanding-of-runtime-goroutine/</guid>
      <description>

&lt;h2 id=&#34;goroutine:11e673671117c063adee6332c59abd2b&#34;&gt;Goroutine&lt;/h2&gt;

&lt;p&gt;大家都知道一个编译好的 Go 程序一般都在 2MB 以上，那是因为 Go 编译器把 Go 的运行环境(runtime)也编译进去了。 一个完整的 Go 程序结构可以表示为下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/7f793092gw1f225uewt4aj20dq0af74i.jpg&#34; alt=&#34;图1&#34; /&gt;
出自 &lt;a href=&#34;http://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf&#34;&gt;7&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在 &lt;a href=&#34;http://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf&#34;&gt;Analysis of the Go runtime scheduler&lt;/a&gt; 中作者们写道：&lt;/p&gt;

&lt;p&gt;我们写的 Go 程序运行在 runtime 之上，当我们要调用 system call 时，runtime 会帮我们与系统打交道。Runtime 有一个 scheduler，它与系统的 scheduler 类似，但不同点是它调度不是系统线程而是 goroutine，而且它是运行在用户空间中（用 intel 的术语来说就是 rang3）。&lt;/p&gt;

&lt;h3 id=&#34;g-m:11e673671117c063adee6332c59abd2b&#34;&gt;g &amp;amp; m&lt;/h3&gt;

&lt;p&gt;Goroutine 与系统线程的对应关系是 &lt;strong&gt;N:M&lt;/strong&gt;，多个goroutine对应多个系统线程，一般来说 gouroutine 的数量远多于系统线程。Goroutine 的运行依托于系统线程，一个线程在这一时刻执行的这个 goroutine，在另一时刻由于 runtime 的调度执行的可能又是另外一个 goroutine。 从系统的角度看，一个 Go 程序就是一个进程，这个进程中都多个线程，系统不知道也不需要知道那些线程中发生 goroutine 的调度。&lt;/p&gt;

&lt;p&gt;在 Golang-nuts 上有一篇贴子 &lt;a href=&#34;https://groups.google.com/forum/#!topic/golang-nuts/SSpxrCrfvyo&#34;&gt;Understanding of runtime goroutine struct G &amp;amp; M&lt;/a&gt;. 在这篇贴子里大家讨论了 runtime 中的 &lt;code&gt;g&lt;/code&gt; 和 &lt;code&gt;m&lt;/code&gt; 结构体，这两个结构体于与 goroutine 的实现相关，简单的来说：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;一个 &lt;strong&gt;g&lt;/strong&gt; 代表一个 &lt;strong&gt;goroutine&lt;/strong&gt;，一个 &lt;strong&gt;m&lt;/strong&gt; 代表一个&lt;strong&gt;系统线程&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;g 运行在 m 中， m 中有多个 g 等待执行。 当运行着的 g 堵塞时，该 m 中剩下的 g 会自动转移到没有被堵塞的 m 中， 这样其余的 goroutine 就不会被堵塞了。当然这一切对程序员是不可见的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;p:11e673671117c063adee6332c59abd2b&#34;&gt;p&lt;/h3&gt;

&lt;p&gt;在 golang-nuts 中并没有提及另外一个重要的结构体 p， 在 &lt;a href=&#34;http://morsmachine.dk/go-scheduler&#34;&gt;morsmachine&lt;/a&gt; 的一篇博文中，他说 p 代表了处理器。
他还说一个 g 要被运行必须要有 p，整个运行结构如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/7f793092gw1f24rq6bgjjj20b40avglr.jpg&#34; alt=&#34;&#34; /&gt;
出自 &lt;a href=&#34;http://morsmachine.dk/go-scheduler&#34;&gt;8&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;每个 p 都有一个本地的 g 队列。 m + p + g 才是一个运行着的 goroutine.&lt;/p&gt;

&lt;h2 id=&#34;gosched:11e673671117c063adee6332c59abd2b&#34;&gt;Gosched&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;runtime.Gosched&lt;/code&gt; 用于让出被执行的权利，使得其他等待中的 goroutine 有机会得以执行，但这并不会终止 Gosched 的 caller。&lt;/p&gt;

&lt;p&gt;明了 Gosched 后，我们再看看它是怎么实现的。下面的 &lt;code&gt;mcall(gosched_m)&lt;/code&gt; 有点蹊跷， mcall 怎么只有一个函数签名，它的函数体在哪里？ &lt;code&gt;gosched_m&lt;/code&gt; 需要一个参数 &lt;code&gt;*g&lt;/code&gt;, 但又它在哪里呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Gosched() {
	mcall(gosched_m)
}

func mcall(fn func(*g))

// Gosched continuation on g0.
func gosched_m(gp *g) {
	if trace.enabled {
		traceGoSched()
	}
	goschedImpl(gp)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mcall:11e673671117c063adee6332c59abd2b&#34;&gt;mcall&lt;/h3&gt;

&lt;p&gt;原来 mcall 是用汇编写的， 每个平台的 mcall 实现方式都不一样。它会提供 fn 当前 goroutine 的 *g。下面我先用伪代码表示 mcall：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// mcall switches from the g to the g0 stack and invokes fn(g),
// where g is the goroutine that made the call.
// mcall saves g&#39;s current PC/SP in g-&amp;gt;sched so that it can be restored later.
// It is up to fn to arrange for that later execution, typically by recording
// g in a data structure, causing something to call ready(g) later.
// mcall returns to the original goroutine g later, when g has been rescheduled.
// fn must not return at all; typically it ends by calling schedule, to let the m
// run other goroutines.
//
// func mcall(fn func(*g))
// Switch to m-&amp;gt;g0&#39;s stack, call fn(g).
// Fn must never return.  It should gogo(&amp;amp;g-&amp;gt;sched)
// to keep running g.
func mcall(fn) {
	g = current_g
	switch stack from current_g to current_m.g0
	call fn(g)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是 mcall 的真实代码，摘取自 asm_amd64.s 文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;TEXT runtime·mcall(SB), NOSPLIT, $0-8
	MOVQ	fn+0(FP), DI
	
	get_tls(CX)
	MOVQ	g(CX), AX	// save state in g-&amp;gt;sched
	MOVQ	0(SP), BX	// caller&#39;s PC
	MOVQ	BX, (g_sched+gobuf_pc)(AX)
	LEAQ	fn+0(FP), BX	// caller&#39;s SP
	MOVQ	BX, (g_sched+gobuf_sp)(AX)
	MOVQ	AX, (g_sched+gobuf_g)(AX)
	MOVQ	BP, (g_sched+gobuf_bp)(AX)

	// switch to m-&amp;gt;g0 &amp;amp; its stack, call fn
	MOVQ	g(CX), BX
	MOVQ	g_m(BX), BX
	MOVQ	m_g0(BX), SI
	CMPQ	SI, AX	// if g == m-&amp;gt;g0 call badmcall
	JNE	3(PC)
	MOVQ	$runtime·badmcall(SB), AX
	JMP	AX
	MOVQ	SI, g(CX)	// g = m-&amp;gt;g0
	MOVQ	(g_sched+gobuf_sp)(SI), SP	// sp = m-&amp;gt;g0-&amp;gt;sched.sp
	PUSHQ	AX
	MOVQ	DI, DX
	MOVQ	0(DI), DI
	CALL	DI
	POPQ	AX
	MOVQ	$runtime·badmcall2(SB), AX
	JMP	AX
	RET
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;MOVQ&lt;/code&gt; 有点像 &lt;a href=&#34;https://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax&#34;&gt;GAS&lt;/a&gt; 汇编的风格，但为什么后面的跟着的不是 &lt;code&gt;r&lt;/code&gt; 系列的64位寄存器呢？ 还有 &lt;code&gt;FP&lt;/code&gt; 是什么东西？
虽然对于汇编我算不上熟练，但看懂，会用的程度我还是有的，这难道不是 GAS？ 赶紧 google 一下。结果还真的不是，&lt;a href=&#34;https://golang.org/doc/asm&#34;&gt;golang&lt;/a&gt; 用的是 &lt;a href=&#34;http://doc.cat-v.org/plan_9/4th_edition/papers/asm&#34;&gt;Plan 9&lt;/a&gt; 的风格。&lt;/p&gt;

&lt;p&gt;Plan 9 汇编风格和 GAS，Intel 风格最大的不同点是它有&lt;strong&gt;伪寄存器&lt;/strong&gt;，比如下面四个：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;FP: Frame pointer: arguments and locals.&lt;/li&gt;
&lt;li&gt;PC: Program counter: jumps and branches.&lt;/li&gt;
&lt;li&gt;SB: Static base pointer: global symbols.&lt;/li&gt;
&lt;li&gt;SP: Stack pointer: top of stack.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;它们用于栈的操作，具体代表什么寄存器由编译链决定，并与 CPU 的架构有关。 FP 用于取函数的参数， &lt;code&gt;0(FP)&lt;/code&gt;， &lt;code&gt;8(FP)&lt;/code&gt;分别代表第一和第二个参数(64位系统)，&lt;/p&gt;

&lt;p&gt;&lt;code&gt;TEXT runtime·mcall(SB), NOSPLIT, $0-8&lt;/code&gt; 表示这里的可执行代码为 runtime.mcall， &lt;code&gt;NOSPLIT&lt;/code&gt; 是个 flag ， &lt;code&gt;$0-8&lt;/code&gt; 0代表这个函数的 stackframe 的大小，8 代表这个函数参数们的大小，中间的 &lt;code&gt;-&lt;/code&gt; 只用于分开两者，并没有其他特殊作用。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MOVQ   fn+0(FP), DI&lt;/code&gt; 把 mcall 的参数 fn 的指针存放到 DI 中， DI 成了一个指向 fn 的指针的指针。 估计后面会有 &lt;code&gt;CALL 0(DI)&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;g-to-g0:11e673671117c063adee6332c59abd2b&#34;&gt;g to g0&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;大体上 mcall 先执行栈的切换，再把当前的 g 作为参数调用 fn。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;保存当前 goroutine 的状态保存到对应的 g 中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34;&gt;MOVQ	g(CX), BX
MOVQ	g_m(BX), BX
MOVQ	0(SP), BX	// caller&#39;s PC
MOVQ	BX, (g_sched+gobuf_pc)(AX)
LEAQ	fn+0(FP), BX	// caller&#39;s SP
MOVQ	BX, (g_sched+gobuf_sp)(AX)
MOVQ	AX, (g_sched+gobuf_g)(AX)
MOVQ	BP, (g_sched+gobuf_bp)(AX)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;g_sched&lt;/code&gt; 是 &lt;a href=&#34;https://github.com/brb/go-static/blob/master/go_asm.h#L876&#34;&gt;sched&lt;/a&gt; 在 g 中的偏移量， &lt;code&gt;gobuf_pc&lt;/code&gt; 是 &lt;a href=&#34;https://github.com/golang/go/blob/master/src/runtime/runtime2.go#L293&#34;&gt;sp&lt;/a&gt; 在 sched 中的 gobuf 的偏移量，依此类推。它们定义在 go_asm.h 文件中。 执行完后，当前 goroutine 的状态将会存放到对应的 g.sched 中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#ifdef GOARCH_amd64
#define	get_tls(r)	MOVQ TLS, r
#define	g(r)	0(r)(TLS*1)
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;get_tls(r)&lt;/code&gt; 是一个宏，定义在 go_tls.h 文件中，它的作用是把当前的 goroutine 的 &lt;em&gt;g&lt;/em&gt; 的指针的地址存到指定的寄存器中（有点绕 - -）。 比如: &lt;code&gt;get_tls(CX)&lt;/code&gt;， CX 中的将会存有当前 g 的地址。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;g(r)&lt;/code&gt; 用于 dereference the pointer of g pointer (实在想不出好的翻译), 比如: &lt;code&gt;g(CX)&lt;/code&gt;, 最终会得到 &lt;code&gt;0(r)(TLS*1)&lt;/code&gt;，解了一层引用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34;&gt;MOVQ	m_g0(BX), SI
MOVQ	SI, g(CX)	// g = m-&amp;gt;g0
MOVQ	(g_sched+gobuf_sp)(SI), SP	// sp = m-&amp;gt;g0-&amp;gt;sched.sp
PUSHQ	AX
MOVQ	DI, DX
MOVQ	0(DI), DI
CALL	DI
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这段代码先把 m.g0 变成 g， 再进行栈的切换，然后把先前 的 g 做为参数推入栈，最后调用 fn。 就这样，mcall 完成了 goroutine 栈的切换并将先前的 g 传入了 fn。&lt;/p&gt;

&lt;p&gt;值得一提的是，几乎的所有汇编文件中都 include 的 go_asm.h， 这个头文件在 golang 的源码中并不存在，它是在编译时&lt;a href=&#34;https://groups.google.com/d/msg/golang-nuts/nRMMvHxsyYQ/n4kLtIHwCAAJ&#34;&gt;自动生成&lt;/a&gt;。 Github 上有一个生成好的 go_asm.h，是 Linux Amd64 的， 有兴趣的同学可以去看一下，&lt;a href=&#34;https://github.com/brb/go-static/blob/master/go_asm.h#L876&#34;&gt;链接在此&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;下面是 g.sched 的具体内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type gobuf struct {
	// The offsets of sp, pc, and g are known to (hard-coded in) libmach.
	sp   uintptr
	pc   uintptr
	g    guintptr
	ctxt unsafe.Pointer // this has to be a pointer so that gc scans it
	ret  uintreg
	lr   uintptr
	bp   uintptr // for GOEXPERIMENT=framepointer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里或许会有点疑问，mcall 保存这么点东西真的足够代表 goroutine 的状态吗？唉，还别说，足够了。 Goroutine 和系统线程不同，一个程序的 Goroutine 全部运行在同一个用户空间，这就意味着没有必要 trap 到 rang0，切换 PageTable(cr3) 或使 TLB 失效。 不过还有一个问题：寄存器的状态呢？确实寄存器的状态是 context 切换的关键点之一。但是不要忘了，这里是调用函数，在调用函数之前一般会把有用的寄存器存到栈中。还是不放心的话，我们来看看真实世界中的 Gosched， 我写了一个简单的例子，并用 go tool compile 获取了它的汇编代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;runtime&amp;quot;

func g1() {
	i := 0
	for {
		i++
		runtime.Gosched()
	}
}

func g2() {
	i, j := 0, 0
	for {
		i++
		runtime.Gosched()
		j += i
	}
}

func main() {
	go g1()
	go g2()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在命令台中输入:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ go build sample.go
$ go tool objdump sample &amp;gt; sample.asm # 汇编代码
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是 g1 的汇编：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34;&gt;sample.go:8	0x401015	4889c3			MOVQ AX, BX    // for loop
sample.go:8	0x401018	48ffc3			INCQ BX        // i++
sample.go:8	0x40101b	48891c24		MOVQ BX, 0(SP) // push i
sample.go:9	0x40101f	e89c2b0200		CALL runtime.Gosched(SB)
sample.go:9	0x401024	488b0424		MOVQ 0(SP), AX // pop i
sample.go:8	0x401028	ebeb			JMP 0x401015   // again
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看见在这段代码中 BX 是那个 &lt;strong&gt;i&lt;/strong&gt;，在这里需要保存的只有 BX，而在 Gosched 之前和之后都有 BX 的栈处理。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34;&gt;sample.go:16	0x40105d	4889cb			MOVQ CX, BX
sample.go:16	0x401060	48ffc3			INCQ BX
sample.go:16	0x401063	48895c2408		MOVQ BX, 0x8(SP)
sample.go:17	0x401068	e8532b0200		CALL runtime.Gosched(SB)
sample.go:17	0x40106d	488b4c2408		MOVQ 0x8(SP), CX
sample.go:18	0x401072	488b1c24		MOVQ 0(SP), BX
sample.go:18	0x401076	4801cb			ADDQ CX, BX
sample.go:18	0x401079	48891c24		MOVQ BX, 0(SP)
sample.go:16	0x40107d	ebde			JMP 0x40105d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同上， g2 在 Gosched 之前，会保存关键的寄存器。&lt;/p&gt;

&lt;p&gt;就像 &lt;a href=&#34;http://doc.cat-v.org/plan_9/4th_edition/papers/asm&#34;&gt;A Manual for the Plan 9 assembler&lt;/a&gt; 所说：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A subroutine is responsible for saving its own registers, and therefore is free to use any registers without saving them (‘‘caller saves’’)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;gogo:11e673671117c063adee6332c59abd2b&#34;&gt;gogo&lt;/h3&gt;

&lt;p&gt;mcall 中保存的信息会在后来的 gogo 中恢复到 g 中，下面的代码摘自 asm_amd64.s。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// void gogo(Gobuf*)
// restore state from Gobuf; longjmp
TEXT runtime·gogo(SB), NOSPLIT, $0-8
	MOVQ	buf+0(FP), BX		// gobuf
	MOVQ	gobuf_g(BX), DX
	MOVQ	0(DX), CX		// make sure g != nil
	get_tls(CX)
	MOVQ	DX, g(CX)
	MOVQ	gobuf_sp(BX), SP	// restore SP
	MOVQ	gobuf_ret(BX), AX
	MOVQ	gobuf_ctxt(BX), DX
	MOVQ	gobuf_bp(BX), BP
	MOVQ	$0, gobuf_sp(BX)	// clear to help garbage collector
	MOVQ	$0, gobuf_ret(BX)
	MOVQ	$0, gobuf_ctxt(BX)
	MOVQ	$0, gobuf_bp(BX)
	MOVQ	gobuf_pc(BX), BX
	JMP	BX
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于 g1, 在 &lt;code&gt;JMP BX&lt;/code&gt; 之后， PC 回到了 &lt;code&gt;0x401024&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;过程:11e673671117c063adee6332c59abd2b&#34;&gt;过程&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;             g
             $
             $          g0
 Gosched --&amp;gt; $ -------&amp;gt; $
                mcall   $
                        $
           schedule --&amp;gt; $
                        $         g&#39;
            execute --&amp;gt; $ ------&amp;gt; $
                           gogo   $
                                  $
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Gosched 的大致过程就像如上面所示， $ 代表 thread of execution，第一条为 g， 第二条是 g0，第三条是调度时被选中执行的 g&amp;rsquo;。&lt;/p&gt;

&lt;h3 id=&#34;schedule:11e673671117c063adee6332c59abd2b&#34;&gt;schedule&lt;/h3&gt;

&lt;p&gt;完整的 schedule 有许多情况要处理，写得有点复杂，简明起见，我只摘录了关键代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func schedule() {
	_g_ := getg()
	if _g_.m.p.ptr().schedtick%61 == 0 &amp;amp;&amp;amp; sched.runqsize &amp;gt; 0 {
		lock(&amp;amp;sched.lock)
		gp = globrunqget(_g_.m.p.ptr(), 1)
		unlock(&amp;amp;sched.lock)
		if gp != nil {
			resetspinning()
		}
	}
	if gp == nil {
		gp, inheritTime = runqget(_g_.m.p.ptr())
		if gp != nil &amp;amp;&amp;amp; _g_.m.spinning {
			throw(&amp;quot;schedule: spinning with local work&amp;quot;)
		}
	}
	if gp == nil {
		gp, inheritTime = findrunnable() // blocks until work is available
		resetspinning()
	}
	execute(gp, inheritTime)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个 if 每隔一段时间会首先运行 globrunqueue 中的 g，这是保证了公平，否则的话只要一个 q localrunqueue 中有两个可运行 g，那么这个 m 就会一直被这两个 g 占据着。&lt;/p&gt;

&lt;p&gt;第二个 if 从 q 本地取一个 g 运行。&lt;/p&gt;

&lt;p&gt;第三个 if 从 globrunqueue 或者其他 p 中取 g，这使得在本地没有可以运行的 g 或没从 globrunqueue 取或 globrunqueue 也没有时，也有 g 可以运行。&lt;/p&gt;

&lt;p&gt;同时这也验证了上面的那幅图片。&lt;/p&gt;

&lt;h2 id=&#34;链接:11e673671117c063adee6332c59abd2b&#34;&gt;链接&lt;/h2&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://groups.google.com/forum/#!topic/golang-nuts/SSpxrCrfvyo&#34;&gt;Understanding of runtime goroutine struct G &amp;amp; M&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax&#34;&gt;X86 Assembly/GAS Syntax&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://golang.org/doc/asm&#34;&gt;A Quick Guide to Go&amp;rsquo;s Assembler&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://doc.cat-v.org/plan_9/4th_edition/papers/asm&#34;&gt;A Manual for the Plan 9 assembler&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://groups.google.com/d/msg/golang-nuts/nRMMvHxsyYQ/n4kLtIHwCAAJ&#34;&gt;Accessing go internals from asm, how to generate go_asm.h?&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/brb/go-static/blob/master/go_asm.h#L876&#34;&gt;go-static/go_asm.h at master · brb/go-static&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/master/src/runtime/runtime2.go#L293&#34;&gt;Analysis of the Go runtime scheduler&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw&#34;&gt;The Go scheduler&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://morsmachine.dk/go-scheduler&#34;&gt;go/runtime2.go at master · golang/go&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw&#34;&gt;Scalable Go Scheduler Design Doc&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;!-- links --&gt;
</description>
    </item>
    
    <item>
      <title>博客搬家了</title>
      <link>http://neilsh.me/2016/02/23/migrating-to-hugo/</link>
      <pubDate>Tue, 23 Feb 2016 15:36:33 +0800</pubDate>
      
      <guid>http://neilsh.me/2016/02/23/migrating-to-hugo/</guid>
      <description>&lt;p&gt;没错，这又是一篇无聊的“搬家”博文（等等，为什么是“又”）。但这次有点特殊，并不是博客托管方的改变，而是博客生成器的变动。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;本博正式从 &lt;a href=&#34;https://hexo.io&#34;&gt;Hexo&lt;/a&gt; 搬到 &lt;a href=&#34;https://gohugo.io&#34;&gt;Hugo&lt;/a&gt; 了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最初促使我抛弃 Hexo 的原因是 Hexo 的文件监视有点问题（至少在我电脑上），开启 hexo 后，文件改动 2-8 次后，hexo 就再也无法观察到文件的变动了。还别说这是个小 feature，它对博文发表最后的微调阶段有很大的影响。&lt;/p&gt;

&lt;p&gt;在多次尝试从外部解决失败后，其中包括重启，升级 Hexo 等，正好看到 golang 也有&lt;a href=&#34;https://gohugo.io&#34;&gt;博客生成器&lt;/a&gt;，一拍脑袋，决定搬家了。&lt;/p&gt;

&lt;p&gt;Hugo 的博文的结构和 Hexo 差不多（呵呵，连名字都错不多，文章结构还能差到哪里去），Markdown 主体，Yaml 元信息。&lt;/p&gt;

&lt;p&gt;后来，渐渐的发现了 Hexo 和 Hugo 其他地方的不同。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;运行时占用内存

&lt;ul&gt;
&lt;li&gt;Hexo: 120M+， Node.js 的锅。&lt;/li&gt;
&lt;li&gt;Hugo: 15M-&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;生成博客，启动 http 服务

&lt;ul&gt;
&lt;li&gt;Hexo: 5s+&lt;/li&gt;
&lt;li&gt;Hugo: 500ms-&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;文档&amp;amp;社区

&lt;ul&gt;
&lt;li&gt;Hexo: English, 正體中文, 简体中文&lt;/li&gt;
&lt;li&gt;Hugo: English only&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面第1和第2项在我电脑上测得，并没有黑 Hexo 的打算，我电脑硬盘是 HDD，对第2项的影响比较大。至于第3项，不得不说 Hexo 太适合国人了，比 Hugo 好很多。&lt;/p&gt;

&lt;p&gt;Hugo 的主题有很多，但都不合我胃口。习惯了&lt;a href=&#34;https://github.com/iissnan/hexo-theme-next&#34;&gt;Next&lt;/a&gt;的风格，想继续用在 Hugo 上，我在现成的主题中找了一圈，觉得 Slender 不错，就是功能少了点，干脆自己给它加上算了。&lt;/p&gt;

&lt;p&gt;于是就有了 &lt;a href=&#34;https://github.com/overvenus/slender-next&#34;&gt;Slender-Next&lt;/a&gt;， 做完后自我感觉不错，干脆就开源吧，哈哈哈。&lt;/p&gt;

&lt;p&gt;Slender-Next 的制作过程也是有惊无险(´≖◞౪◟≖)，Golang 已经学了一段时间了，对 Hugo 文档有什么不明白的，直接看源码，哈哈，事倍功半啊。&lt;/p&gt;

&lt;p&gt;把博文迁移到 Hugo 并不复杂但就怕多，搬家前我有 18 篇，算不上多，但还是花了不少时间。我习惯一篇博文一个分支，这很方便搬家，&lt;code&gt;git cherry-pick&lt;/code&gt;就行了，还保留了文章的历史记录，哈哈哈，太机智了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introducing Slender-Next</title>
      <link>http://neilsh.me/2016/02/23/introducing-slender-next/</link>
      <pubDate>Tue, 23 Feb 2016 14:25:32 +0800</pubDate>
      
      <guid>http://neilsh.me/2016/02/23/introducing-slender-next/</guid>
      <description>

&lt;h2 id=&#34;slender-next:3c4e2d208ca79d5efa86c04d997b2fbe&#34;&gt;Slender-Next&lt;/h2&gt;

&lt;p&gt;Yet another sample theme for &lt;a href=&#34;http://gohugo.io/&#34;&gt;Hugo&lt;/a&gt; with &lt;a href=&#34;https://github.com/chriskempson/base16&#34;&gt;base16&lt;/a&gt; color schemes.&lt;/p&gt;

&lt;p&gt;Based on &lt;a href=&#34;https://github.com/CrimsonRay/slender&#34;&gt;slender&lt;/a&gt;, inspired by &lt;a href=&#34;https://github.com/iissnan/hexo-theme-next&#34;&gt;hexo-theme-next&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;screenshot:3c4e2d208ca79d5efa86c04d997b2fbe&#34;&gt;Screenshot&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://neilsh.me/assets/img/slender-next/screenshot.png&#34; alt=&#34;screenshot&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;features:3c4e2d208ca79d5efa86c04d997b2fbe&#34;&gt;Features&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Responsive&lt;/li&gt;
&lt;li&gt;Pagination&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/chriskempson/base16&#34;&gt;base16&lt;/a&gt; color schemes&lt;/li&gt;
&lt;li&gt;Code/syntax highlighting with &lt;a href=&#34;https://highlightjs.org/&#34;&gt;highlight.js 9.1.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Proper meta tags for SEO&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Optimized for China&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Google Analytics And Baidu Tongji integration&lt;/li&gt;
&lt;li&gt;Disqus And Duoshuo integration&lt;/li&gt;
&lt;li&gt;MathJax support&lt;/li&gt;
&lt;li&gt;Table of Content&lt;/li&gt;
&lt;li&gt;Tags + Archive&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;color-schemes:3c4e2d208ca79d5efa86c04d997b2fbe&#34;&gt;Color Schemes&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://neilsh.me/assets/img/slender-next/slender-color-schemes.png&#34; alt=&#34;slender-color-schemes&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;installation:3c4e2d208ca79d5efa86c04d997b2fbe&#34;&gt;Installation&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Make a new Hugo site&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;$ hugo new site your_site/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Install Slender&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;$ cd your_site/
$ mkdir themes
$ cd themes
$ git clone https://github.com/overvenus/slender-next
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;configuration:3c4e2d208ca79d5efa86c04d997b2fbe&#34;&gt;Configuration&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# config.toml
# https://github.com/overvenus/slender-next

baseurl = &amp;quot;http://url-to-your-site.com/&amp;quot;
title = &amp;quot;Your Title&amp;quot;
# set &amp;quot;zh-Hans&amp;quot;, turn on optimization.
languageCode = &amp;quot;en-US&amp;quot;
MetaDataFormat = &amp;quot;yaml&amp;quot;
theme = &amp;quot;slender-next&amp;quot;
paginate = 5
PaginatePath = &amp;quot;/page/&amp;quot;

[author]
    name = &amp;quot;Your Name&amp;quot;

[permalinks]

    # Permalink format for pages.
    page = &amp;quot;/:title/&amp;quot;

    # Permalink format for blog posts.
    post = &amp;quot;/:year/:month/:day/:title/&amp;quot;

[taxonomies]
    # tags -&amp;gt; menu.main.tags
    tag = &amp;quot;tags&amp;quot;
    # archive -&amp;gt; menu.main.archive
    archive = &amp;quot;archive&amp;quot;

[params]

    # Change the color scheme of Slender.
    # See above for preview and list of color schemes.
    colorscheme = &amp;quot;white&amp;quot;

    # Tagline; HTML accepted here. Keep it concise.
    tagline = &amp;quot;Your Tagline&amp;quot;

    # copyright, see http://creativecommons.org/
    licenses = &amp;quot;BY-NC-SA&amp;quot;

    # Description and keywords for &amp;lt;meta&amp;gt; tags.
    # Remember to set this for your main page.
    # This will be overridden by whatever is set by the page or post,
    # defined by `description` and `keywords` variables in the front matter
    # of the markdown file.
    description = &amp;quot;Default Page Description&amp;quot;
    keywords = &amp;quot;default,page,keywords&amp;quot;

    # Analytics
    # Remove, comment, or leave it blank if you don&#39;t have one.
    googleAnalytics = &amp;quot;GoogleAnalyticsParams&amp;quot;
    baiduTongji = &amp;quot;BaiduTongji&amp;quot;

    # Comment
    # Remove or comment if you don&#39;t have one.
    # if both set,
    #    zh-Hans: duoshuoShortname &amp;gt; disqusShortname
    #    else: disqusShortname &amp;gt; duoshuoShortname
    duoshuoShortname = &amp;quot;your-duoshuo&amp;quot;
    disqusShortname = &amp;quot;you-disqus&amp;quot;

    # MathJax
    # see: http://mathjax.readthedocs.org/en/latest/options/hub.html
    mathjax = true # enable
    mathHideMenu = false
    mathZoom = &amp;quot;Double-Click&amp;quot;
    mathRenderer = &amp;quot;SVG&amp;quot;

[menu]

    # Menu for the nav bar.
    # There must always be one item present (e.g. home).
    # identifier: Font Awesome icon name
    [[menu.main]]
    identifier = &amp;quot;fa-home&amp;quot;
    name       = &amp;quot;Home&amp;quot;
    url        = &amp;quot;/&amp;quot;
    weight     = 0

    [[menu.main]]
    identifier = &amp;quot;fa-user&amp;quot;
    name       = &amp;quot;About&amp;quot;
    url        = &amp;quot;/about/&amp;quot;
    weight     = 1

    [[menu.main]]
    identifier = &amp;quot;fa-archive&amp;quot;
    name       = &amp;quot;Archive&amp;quot;
    url        = &amp;quot;/archive/&amp;quot;
    weight     = 2

    [[menu.main]]
    identifier = &amp;quot;fa-tags&amp;quot;
    name       = &amp;quot;Tags&amp;quot;
    url        = &amp;quot;/tags/&amp;quot;
    weight     = 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;usage:3c4e2d208ca79d5efa86c04d997b2fbe&#34;&gt;Usage&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Making a new post / article&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;$ hugo new post/hello.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Making a new page&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;$ hugo new page/about.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add the new page to navbar in &lt;code&gt;config.toml&lt;/code&gt; under &lt;code&gt;[menu]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Turn on MathJax&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Post&amp;rsquo;s front matter. Default: &amp;ldquo;off&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
mathjax: &amp;quot;on&amp;quot;
---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Turn off TOC&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Post&amp;rsquo;s front matter. Default: &amp;ldquo;on&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
toc: &amp;quot;off&amp;quot;
---
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;license:3c4e2d208ca79d5efa86c04d997b2fbe&#34;&gt;License&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;LICENSE.md&#34;&gt;MIT&lt;/a&gt; &amp;copy; 2015 CrimsonRay&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;LICENSE.md&#34;&gt;MIT&lt;/a&gt; &amp;copy; 2016 Neil Shen&lt;/p&gt;

&lt;h2 id=&#34;get-it-now:3c4e2d208ca79d5efa86c04d997b2fbe&#34;&gt;Get it NOW!&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/overvenus/slender-next&#34;&gt;Slender-Next&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Debian Packaging 教程</title>
      <link>http://neilsh.me/2016/01/20/debian-packaging-step-by-step/</link>
      <pubDate>Wed, 20 Jan 2016 20:54:10 +0800</pubDate>
      
      <guid>http://neilsh.me/2016/01/20/debian-packaging-step-by-step/</guid>
      <description>

&lt;h2 id=&#34;新手之痛:9dbabb1bf2ebe1b2c5fa8a0fc6e26c07&#34;&gt;新手之痛&lt;/h2&gt;

&lt;p&gt;说实话把自己的程序打包成 deb， 对新手来说，真的不容易。网上的文档都太烦，烦到看不懂，涉及到很多工具，比如这句命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install build-essential devscripts ubuntu-dev-tools debhelper dh-make diff patch cdbs quilt gnupg fakeroot lintian pbuilder piuparts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些文档写得也是如何打包别人的源码，但关键别人的 debian 配置文件多，每个文件的代码也都很多，还不如看文档。还有的项目更过分，连 debian 的配置文件都不给出。（迷之眼泪 (╥﹏╥)&lt;/p&gt;

&lt;p&gt;有志者事竟成，我倒腾了几天终于有成功了，打包出了 deb，Launchpad 上也有了我的 PPA。这儿记录一下，防止自己忘记，也方便新人入门。&lt;/p&gt;

&lt;p&gt;我&lt;strong&gt;没有&lt;/strong&gt;严格遵守 Debian 社区打包的步骤，这记录的是一个 quick and dirty way not the Debian way!这是大概的过程:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;创建 GPG: 用于给 deb 签名&lt;/li&gt;
&lt;li&gt;打包 DEB: 有点麻烦，规矩多，步骤多&lt;/li&gt;
&lt;li&gt;上传 Launchpad: 添加到 PPA，以后安装就方便了&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;创建-gpg:9dbabb1bf2ebe1b2c5fa8a0fc6e26c07&#34;&gt;创建 GPG&lt;/h2&gt;

&lt;p&gt;阮一峰有一篇非常棒的 &lt;a href=&#34;http://www.ruanyifeng.com/blog/2013/07/gpg.html&#34;&gt;GPG入门教程&lt;/a&gt;，里面涵盖了新手上手 GPG 所需的基本步骤。&lt;/p&gt;

&lt;p&gt;我在这补充一下，他的文章中上传公钥使用的是 &lt;code&gt;hkp://subkeys.pgp.net&lt;/code&gt;，我这试了几次都出现了连接错误。所以，我推荐 &lt;code&gt;hkp://keyserver.ubuntu.com&lt;/code&gt;，使用它，不仅是因为连得上，还因为在 Launchpad 创建 PPA 也要用它。&lt;/p&gt;

&lt;h2 id=&#34;创建-ppa:9dbabb1bf2ebe1b2c5fa8a0fc6e26c07&#34;&gt;创建 PPA&lt;/h2&gt;

&lt;p&gt;摘自 &lt;a href=&#34;http://askubuntu.com/a/71516/436021&#34;&gt;How do I create a PPA?&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://login.launchpad.net/+new_account&#34;&gt;创建 Launchpad 帐号&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://launchpad.net/people/+me/&#34;&gt;激活 PPA&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;用 GPG 签约 &lt;a href=&#34;https://launchpad.net/codeofconduct&#34;&gt;the Ubuntu code of conduct&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;打包-deb:9dbabb1bf2ebe1b2c5fa8a0fc6e26c07&#34;&gt;打包 DEB&lt;/h2&gt;

&lt;p&gt;这儿以我的最近写的 &lt;a href=&#34;http://neilsh.me/2016/01/20/tbutton-mini-commands-launcher/&#34;&gt;TButton&lt;/a&gt; 为例。TButton 关键就 3 个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;➜  indicator-tbutton-0.1  tree
.
├── indicator-tbutton
├── indicator-tbutton.desktop
└── tbutton-icon.png

0 directories, 3 files
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对上面命令的解释：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;➜&lt;/code&gt; :一行新命令的开始标志&lt;/p&gt;

&lt;p&gt;&lt;code&gt;indicator-tbutton-0.1&lt;/code&gt; : 当前文件夹&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tree&lt;/code&gt; : Linux 命令，列出当前目录的结构&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;准备工作:9dbabb1bf2ebe1b2c5fa8a0fc6e26c07&#34;&gt;准备工作&lt;/h3&gt;

&lt;p&gt;在开始之前先把一些&lt;strong&gt;准备工作&lt;/strong&gt;做好。&lt;/p&gt;

&lt;h4 id=&#34;安装工具:9dbabb1bf2ebe1b2c5fa8a0fc6e26c07&#34;&gt;安装工具&lt;/h4&gt;

&lt;p&gt;我没有安装上面提及的所以工具，这条命令会安装这篇教程中涉及到的工具。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt-get insatll build-essential debhelper fakeroot dh-make lintian dput python-bzrlib tree vim
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;维护者信息:9dbabb1bf2ebe1b2c5fa8a0fc6e26c07&#34;&gt;维护者信息&lt;/h4&gt;

&lt;p&gt;向控制台配置文件(一般为 &lt;code&gt;～/.bashrc&lt;/code&gt; 或者 &lt;code&gt;~/.zshrc&lt;/code&gt;)中添加：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;export DEBEMAIL=&amp;lt;YOUR EMAIL&amp;gt;   # 我们的电子邮件地址
export DEBFULLNAME=&amp;lt;YOUR NAME&amp;gt; # 我们的真实姓名
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个信息在生成 debian 配置文件，也就是下面 &lt;em&gt;第6步&lt;/em&gt; 中会被用到。&lt;/p&gt;

&lt;h3 id=&#34;创建-debian-模板:9dbabb1bf2ebe1b2c5fa8a0fc6e26c07&#34;&gt;创建 debian 模板&lt;/h3&gt;

&lt;p&gt;创建步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在 Home 文件夹里创建个叫 sandbox 的文件夹&lt;/li&gt;
&lt;li&gt;把 indicator-tbutton-0.1 文件夹复制到 sandbox&lt;/li&gt;
&lt;li&gt;把 indicator-tbutton-0.1 文件夹整个打包成 indicator-tbutton-0.1.tar.gz&lt;/li&gt;
&lt;li&gt;把 indicator-tbutton-0.1.tar.gz 移动到 indicator-tbutton-0.1 文件夹中&lt;/li&gt;
&lt;li&gt;进入 indicator-tbutton-0.1 文件夹中&lt;/li&gt;
&lt;li&gt;运行 &lt;code&gt;dh_make&lt;/code&gt;，参数： （完整文档可以运行&lt;code&gt;man dh_make&lt;/code&gt;）

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-c gpl3&lt;/code&gt;: license 信息，我这儿用 GPLv3&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-f indicator-tbutton-0.1.tar.gz&lt;/code&gt;: 指定&lt;strong&gt;原&lt;/strong&gt;源代码压缩包&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;删除不必要的文件，具体可以参见 &lt;a href=&#34;https://github.com/overvenus/tbutton/tree/master/packagebuild/indicator-tbutton-template/debian&#34;&gt;TButton/debian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;编辑 debian 文件夹中的配置文件&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;➜  ~  cp -R indicator-tbutton-0.1 sandbox
➜  ~  cd sandbox 
➜  sandbox  tree
.
└── indicator-tbutton-0.1
    ├── indicator-tbutton
    ├── indicator-tbutton.desktop
    └── tbutton-icon.png

1 directory, 3 files

➜  sandbox  tar -cvzf indicator-tbutton-0.1.tar.gz indicator-tbutton-0.1
indicator-tbutton-0.1/
indicator-tbutton-0.1/tbutton-icon.png
indicator-tbutton-0.1/indicator-tbutton
indicator-tbutton-0.1/indicator-tbutton.desktop

➜  sandbox  cp indicator-tbutton-0.1.tar.gz indicator-tbutton-0.1/
➜  sandbox  cd indicator-tbutton-0.1 
➜  indicator-tbutton-0.1  tree
.
├── indicator-tbutton
├── indicator-tbutton-0.1.tar.gz
├── indicator-tbutton.desktop
└── tbutton-icon.png

0 directories, 4 files

➜  indicator-tbutton-0.1  dh_make -c gpl3  -f indicator-tbutton-0.1.tar.gz

Type of package: single binary, indep binary, multiple binary, library, kernel module, kernel patch?
 [s/i/m/l/k/n] s  # 这里输入 s

Maintainer name  : Neil Shen
Email-Address    : overvenus@gmail.com 
Date             : Thu, 21 Jan 2016 14:07:51 +0800
Package Name     : indicator-tbutton
Version          : 0.1
License          : gpl3
Type of Package  : Single
Hit &amp;lt;enter&amp;gt; to confirm:   # 这里按回车
Currently there is no top level Makefile. This may require additional tuning.
Done. Please edit the files in the debian/ subdirectory now. You should also
check that the indicator-tbutton Makefiles install into $DESTDIR and not in / .

➜  indicator-tbutton-0.1  tree
.
├── debian
│   ├── changelog
│   ├── compat
│   ├── control
│   ├── copyright
│   ├── docs
│   ├── indicator-tbutton.cron.d.ex
│   ├── indicator-tbutton.default.ex
│   ├── indicator-tbutton.doc-base.EX
│   ├── init.d.ex
│   ├── manpage.1.ex
│   ├── manpage.sgml.ex
│   ├── manpage.xml.ex
│   ├── menu.ex
│   ├── postinst.ex
│   ├── postrm.ex
│   ├── preinst.ex
│   ├── prerm.ex
│   ├── README.Debian
│   ├── README.source
│   ├── rules
│   ├── source
│   │   └── format
│   └── watch.ex
├── indicator-tbutton
├── indicator-tbutton-0.1.tar.gz
├── indicator-tbutton.desktop
└── tbutton-icon.png

2 directories, 26 files

# 删除文件ing...
# 最终目录结构
➜  indicator-tbutton-0.1  cd ..
➜  sandbox  tree 
.
├── indicator-tbutton-0.1
│   ├── debian
│   │   ├── changelog
│   │   ├── compat
│   │   ├── control
│   │   ├── copyright
│   │   ├── rules
│   │   └── source
│   │       └── format
│   ├── indicator-tbutton
│   ├── indicator-tbutton.desktop
│   └── tbutton-icon.png
└── indicator-tbutton_0.1.orig.tar.gz

3 directories, 10 files
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;编辑-debian-配置文件:9dbabb1bf2ebe1b2c5fa8a0fc6e26c07&#34;&gt;编辑 debian 配置文件&lt;/h3&gt;

&lt;p&gt;配置文件指的是 &lt;code&gt;debian\&lt;/code&gt; 文件夹下的那几个文件，每个都有不同的功能，有的一旦配置完以后都不用去改动，还有的每次发布都到改动。
对几个重要文件的说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;changelog: 记录每次发布的对软件的更改和控制发布的版本号&lt;/li&gt;
&lt;li&gt;rule: 控制如何安装软件, 语法于 Makefile 类似（可以参看我的 rule）&lt;/li&gt;
&lt;li&gt;copyright: 软件的版权与发布协议&lt;/li&gt;
&lt;li&gt;control: 维护者信息，软件简介，依赖&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面四个文件是我们需要编辑的，具体内容怎么写可以参照 &lt;a href=&#34;https://github.com/overvenus/tbutton/tree/master/packagebuild/indicator-tbutton-template/debian&#34;&gt;TButton/debian&lt;/a&gt;，详细信息请看 &lt;a href=&#34;http://www.debian.org/doc/manuals/maint-guide/&#34;&gt;Debian New Maintainers’ Guide&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;本地打包测试:9dbabb1bf2ebe1b2c5fa8a0fc6e26c07&#34;&gt;本地打包测试&lt;/h3&gt;

&lt;p&gt;到了这一步就简单了，就是一句命令的事儿 &amp;mdash; &lt;code&gt;fakeroot dpkg-buildpackage -F&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;-F&lt;/code&gt; : 以完全模式打包，创建 .deb 文件，打包源码，GPG 签名等等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 接上面
➜  sandbox  cd indicator-tbutton-0.1 
➜  indicator-tbutton-0.1  fakeroot dpkg-buildpackage -F 
dpkg-buildpackage: source package indicator-tbutton-0.1
dpkg-buildpackage: source version 0.1-1
dpkg-buildpackage: source distribution trusty
dpkg-buildpackage: source changed by Neil Shen &amp;lt;overvenus@gmail.com&amp;gt;
dpkg-buildpackage: host architecture amd64
 dpkg-source --before-build indicator-tbutton-0.1
 debian/rules clean
dh_testdir
dh_testroot
rm -f build-stamp
dh_clean
 dpkg-source -b indicator-tbutton-0.1
dpkg-source: error: can&#39;t build with source format &#39;3.0 (quilt)&#39;: no upstream tarball found at ../indicator-tbutton-0.1_0.1.orig.tar.{bz2,gz,lzma,xz}
dpkg-buildpackage: error: dpkg-source -b indicator-tbutton-0.1 gave error exit status 255
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oops，出错了！来看看是什么错误。。。
哦，原来是没有找到 &lt;code&gt;../indicator-tbutton-0.1_0.1.orig.tar.{bz2,gz,lzma,xz}&lt;/code&gt;，我们在 sandbox 下有 &lt;code&gt;indicator-tbutton_0.1.orig.tar.gz&lt;/code&gt; 但是，dpkg 要求我们提供 &lt;code&gt;indicator-tbutton-0.1_0.1.orig.tar.gz&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;➜  indicator-tbutton-0.1  cd ..
➜  sandbox  ls
indicator-tbutton-0.1  indicator-tbutton_0.1.orig.tar.gz
# 重命名
➜  sandbox  mv indicator-tbutton_0.1.orig.tar.gz indicator-tbutton-0.1_0.1.orig.tar.gz
➜  sandbox  ls
indicator-tbutton-0.1  indicator-tbutton-0.1_0.1.orig.tar.gz
➜  sandbox  cd indicator-tbutton-0.1 
# 再来试一下
➜  indicator-tbutton-0.1  fakeroot dpkg-buildpackage -F 
dpkg-buildpackage: source package indicator-tbutton-0.1
dpkg-buildpackage: source version 0.1-1
dpkg-buildpackage: source distribution trusty
dpkg-buildpackage: source changed by Neil Shen &amp;lt;overvenus@gmail.com&amp;gt;
dpkg-buildpackage: host architecture amd64
 dpkg-source --before-build indicator-tbutton-0.1
 debian/rules clean
dh_testdir
dh_testroot
rm -f build-stamp
dh_clean
 dpkg-source -b indicator-tbutton-0.1
dpkg-source: info: using source format `3.0 (quilt)&#39;
dpkg-source: info: building indicator-tbutton-0.1 using existing ./indicator-tbutton-0.1_0.1.orig.tar.gz
dpkg-source: info: building indicator-tbutton-0.1 in indicator-tbutton-0.1_0.1-1.debian.tar.gz
dpkg-source: info: building indicator-tbutton-0.1 in indicator-tbutton-0.1_0.1-1.dsc
 debian/rules build
dh_testdir
touch configure-stamp
touch build-stamp
 debian/rules binary
dh_testdir
dh_testroot
dh_prep
dh_installdirs
mkdir -m 755 -p /home/neil/sandbox/indicator-tbutton-0.1/debian/indicator-tbutton/usr/bin
mkdir -m 755 -p /home/neil/sandbox/indicator-tbutton-0.1/debian/indicator-tbutton/usr/share/applications
mkdir -m 755 -p /home/neil/sandbox/indicator-tbutton-0.1/debian/indicator-tbutton/usr/share/icons/hicolor/96x96/apps
mkdir -m 755 -p /home/neil/sandbox/indicator-tbutton-0.1/debian/indicator-tbutton/etc/xdg/autostart
install -m 755 /home/neil/sandbox/indicator-tbutton-0.1/indicator-tbutton /home/neil/sandbox/indicator-tbutton-0.1/debian/indicator-tbutton/usr/bin
install -m 644 /home/neil/sandbox/indicator-tbutton-0.1/tbutton-icon.png /home/neil/sandbox/indicator-tbutton-0.1/debian/indicator-tbutton/usr/share/icons/hicolor/96x96/apps
install -m 644 /home/neil/sandbox/indicator-tbutton-0.1/indicator-tbutton.desktop /home/neil/sandbox/indicator-tbutton-0.1/debian/indicator-tbutton/usr/share/applications
install -m 644 /home/neil/sandbox/indicator-tbutton-0.1/indicator-tbutton.desktop /home/neil/sandbox/indicator-tbutton-0.1/debian/indicator-tbutton/etc/xdg/autostart
dh_testdir
dh_testroot
dh_installchangelogs
dh_installdocs
dh_icons
dh_installmenu
# dh_python2
# dh_pysupport
dh_link
dh_strip
dh_compress
dh_fixperms
dh_installdeb
dh_gencontrol
dpkg-gencontrol: warning: Depends field of package indicator-tbutton: unknown substitution variable ${python:Depends}
dpkg-gencontrol: warning: Depends field of package indicator-tbutton: unknown substitution variable ${shlibs:Depends}
dh_md5sums
dh_builddeb
dpkg-deb: building package `indicator-tbutton&#39; in `../indicator-tbutton_0.1-1_amd64.deb&#39;.
 signfile indicator-tbutton-0.1_0.1-1.dsc

You need a passphrase to unlock the secret key for
user: &amp;quot;Neil Shen &amp;lt;overvenus@gmail.com&amp;gt;&amp;quot;
2048-bit RSA key, ID 90E9FAC7, created 2015-12-27


 dpkg-genchanges  &amp;gt;../indicator-tbutton-0.1_0.1-1_amd64.changes
dpkg-genchanges: including full source code in upload
 signfile indicator-tbutton-0.1_0.1-1_amd64.changes

You need a passphrase to unlock the secret key for
user: &amp;quot;Neil Shen &amp;lt;overvenus@gmail.com&amp;gt;&amp;quot;
2048-bit RSA key, ID 90E9FAC7, created 2015-12-27


 dpkg-source --after-build indicator-tbutton-0.1
dpkg-buildpackage: full upload (original source is included)

➜  indicator-tbutton-0.1  cd ..
➜  sandbox  ls
indicator-tbutton-0.1
indicator-tbutton-0.1_0.1-1_amd64.changes
indicator-tbutton-0.1_0.1-1.debian.tar.gz
indicator-tbutton-0.1_0.1-1.dsc
indicator-tbutton-0.1_0.1.orig.tar.gz
indicator-tbutton_0.1-1_amd64.deb

# OK! 大功告成
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们有了 .deb 文件，先把它解压，看看有没有打包进全部的文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;➜  sandbox  mkdir temp
➜  sandbox  dpkg -x indicator-tbutton_0.1-1_amd64.deb temp
➜  sandbox  tree
.
├── indicator-tbutton-0.1
│   ├── build-stamp
│   ├── configure-stamp
│   ├── debian
│   │   ├── changelog
│   │   ├── compat
│   │   ├── control
│   │   ├── copyright
│   │   ├── files
│   │   ├── indicator-tbutton
│   │   │   ├── DEBIAN
│   │   │   │   ├── conffiles
│   │   │   │   ├── control
│   │   │   │   └── md5sums
│   │   │   ├── etc
│   │   │   │   └── xdg
│   │   │   │       └── autostart
│   │   │   │           └── indicator-tbutton.desktop
│   │   │   └── usr
│   │   │       ├── bin
│   │   │       │   └── indicator-tbutton
│   │   │       └── share
│   │   │           ├── applications
│   │   │           │   └── indicator-tbutton.desktop
│   │   │           ├── doc
│   │   │           │   └── indicator-tbutton
│   │   │           │       ├── changelog.Debian.gz
│   │   │           │       └── copyright
│   │   │           └── icons
│   │   │               └── hicolor
│   │   │                   └── 96x96
│   │   │                       └── apps
│   │   │                           └── tbutton-icon.png
│   │   ├── indicator-tbutton.debhelper.log
│   │   ├── indicator-tbutton.substvars
│   │   ├── rules
│   │   └── source
│   │       └── format
│   ├── indicator-tbutton
│   ├── indicator-tbutton.desktop
│   └── tbutton-icon.png
├── indicator-tbutton-0.1_0.1-1_amd64.changes
├── indicator-tbutton-0.1_0.1-1.debian.tar.gz
├── indicator-tbutton-0.1_0.1-1.dsc
├── indicator-tbutton-0.1_0.1.orig.tar.gz
├── indicator-tbutton_0.1-1_amd64.deb
└── temp
    ├── etc
    │   └── xdg
    │       └── autostart
    │           └── indicator-tbutton.desktop
    └── usr
        ├── bin
        │   └── indicator-tbutton
        └── share
            ├── applications
            │   └── indicator-tbutton.desktop
            ├── doc
            │   └── indicator-tbutton
            │       ├── changelog.Debian.gz
            │       └── copyright
            └── icons
                └── hicolor
                    └── 96x96
                        └── apps
                            └── tbutton-icon.png

32 directories, 34 files
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perfect! 全部打包了！ ヽ(○´∀`)ﾉ♪&lt;/p&gt;

&lt;p&gt;如果电脑中有装有 Ubuntu 的虚拟机的话，可以在里面安装，再次验证。&lt;/p&gt;

&lt;p&gt;如果我们还有耐心的话，可用 lintain 来检查 deb 包的其他问题。下面是我的 .deb 问题，两个警告，一个错误，但并无大碍。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;➜  sandbox  lintian indicator-tbutton_0.1-1_amd64.deb
W: indicator-tbutton: new-package-should-close-itp-bug
W: indicator-tbutton: binary-without-manpage usr/bin/indicator-tbutton
E: indicator-tbutton: python-script-but-no-python-dep usr/bin/indicator-tbutton
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;上传-launchpad:9dbabb1bf2ebe1b2c5fa8a0fc6e26c07&#34;&gt;上传 Launchpad&lt;/h2&gt;

&lt;p&gt;最后一部分，涉及的工具只有 &lt;code&gt;dput&lt;/code&gt;。首先，先要对它配置一下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;➜  sandbox  vim ~/.dput.cf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[my-ppa]
fqdn = ppa.launchpad.net
method = sftp               # 确保我们已将 ssh-key 添加到 Launchpad!
incoming = &amp;lt;YOUR PPA PATH&amp;gt;  # 这是我的： ~overvenus/ubuntu/ppa/
login = &amp;lt;YOUR ACCONT NAME&amp;gt;  # 这是我的： overvenus
allow_unsigned_uploads = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上传之前，我们先要清理一下，然后换个模式 build， &lt;code&gt;fakeroot dpkg-buildpackage -S&lt;/code&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;-S&lt;/code&gt; : 只打包源码，GPG 签名。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;➜  sandbox  ls
indicator-tbutton-0.1
indicator-tbutton-0.1_0.1-1_amd64.changes
indicator-tbutton-0.1_0.1-1.debian.tar.gz
indicator-tbutton-0.1_0.1-1.dsc
indicator-tbutton-0.1_0.1.orig.tar.gz
indicator-tbutton_0.1-1_amd64.deb
temp

# 删除文件ing
➜  sandbox  rm -r indicator-tbutton-0.1_0.1-1_amd64.changes indicator-tbutton-0.1_0.1-1.debian.tar.gz indicator-tbutton-0.1_0.1-1.dsc indicator-tbutton_0.1-1_amd64.deb temp
➜  sandbox  ls
indicator-tbutton-0.1  indicator-tbutton-0.1_0.1.orig.tar.gz

# 清理
➜  sandbox  cd indicator-tbutton-0.1 
➜  indicator-tbutton-0.1  dh_clean
#  换个模式 build
➜  indicator-tbutton-0.1  fakeroot dpkg-buildpackage -S 
dpkg-buildpackage: source package indicator-tbutton-0.1
dpkg-buildpackage: source version 0.1-1
dpkg-buildpackage: source distribution trusty
dpkg-buildpackage: source changed by Neil Shen &amp;lt;overvenus@gmail.com&amp;gt;
 dpkg-source --before-build indicator-tbutton-0.1
 debian/rules clean
dh_testdir
dh_testroot
rm -f build-stamp
dh_clean
 dpkg-source -b indicator-tbutton-0.1
dpkg-source: info: using source format `3.0 (quilt)&#39;
dpkg-source: info: building indicator-tbutton-0.1 using existing ./indicator-tbutton-0.1_0.1.orig.tar.gz
dpkg-source: info: building indicator-tbutton-0.1 in indicator-tbutton-0.1_0.1-1.debian.tar.gz
dpkg-source: info: building indicator-tbutton-0.1 in indicator-tbutton-0.1_0.1-1.dsc
 signfile indicator-tbutton-0.1_0.1-1.dsc

You need a passphrase to unlock the secret key for
user: &amp;quot;Neil Shen &amp;lt;overvenus@gmail.com&amp;gt;&amp;quot;
2048-bit RSA key, ID 90E9FAC7, created 2015-12-27


 dpkg-genchanges -S &amp;gt;../indicator-tbutton-0.1_0.1-1_source.changes
dpkg-genchanges: including full source code in upload
 signfile indicator-tbutton-0.1_0.1-1_source.changes

You need a passphrase to unlock the secret key for
user: &amp;quot;Neil Shen &amp;lt;overvenus@gmail.com&amp;gt;&amp;quot;
2048-bit RSA key, ID 90E9FAC7, created 2015-12-27


 dpkg-source --after-build indicator-tbutton-0.1
dpkg-buildpackage: full upload (original source is included)

# 注意，没有 deb！
➜  indicator-tbutton-0.1  cd ..
➜  sandbox  ls
indicator-tbutton-0.1
indicator-tbutton-0.1_0.1-1.debian.tar.gz
indicator-tbutton-0.1_0.1-1.dsc
indicator-tbutton-0.1_0.1-1_source.changes
indicator-tbutton-0.1_0.1.orig.tar.gz
# 上传到 PPA
➜  sandbox  dput my-ppa  indicator-tbutton-0.1_0.1-1_source.changes
Checking signature on .changes
gpg: Signature made Friday, January 22, 2016 PM03:49:06 CST using RSA key ID 90E9FAC7
gpg: Good signature from &amp;quot;Neil Shen &amp;lt;overvenus@gmail.com&amp;gt;&amp;quot;
Good signature on /home/neil/sandbox/indicator-tbutton-0.1_0.1-1_source.changes.
Checking signature on .dsc
gpg: Signature made Friday, January 22, 2016 PM03:49:06 CST using RSA key ID 90E9FAC7
gpg: Good signature from &amp;quot;Neil Shen &amp;lt;overvenus@gmail.com&amp;gt;&amp;quot;
Good signature on /home/neil/sandbox/indicator-tbutton-0.1_0.1-1.dsc.
Uploading to my-ppa (via sftp to ppa.launchpad.net):
  indicator-tbutton-0.1_0.1-1.dsc: Agent admitted failure to sign using the key.
Enter passphrase for key &#39;/home/neil/.ssh/id_rsa&#39;: 
...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等上传完毕后 Launchpad 会发一封邮件给我们，被接受，会有以下回复。被拒，也会把原因写在邮件中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ww2.sinaimg.cn/large/7f793092gw1f08c4vj25bj20hf0d141a.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果一切正常，30 分钟后，我们就能从 PPA 中安装我们的软件。比如安装 TButton：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo add-apt-repository ppa:overvenus/ppa
sudo apt-get update
sudo apt-get install indicator-tbutton
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考链接:9dbabb1bf2ebe1b2c5fa8a0fc6e26c07&#34;&gt;参考链接&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://neilsh.me/2016/01/20/tbutton-mini-commands-launcher/&#34;&gt;TButton&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/overvenus/tbutton/tree/master/packagebuild/indicator-tbutton-template/debian&#34;&gt;TButton/debian&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2013/07/gpg.html&#34;&gt;GPG入门教程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://askubuntu.com/a/71516/436021&#34;&gt;How do I create a PPA?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://packaging.ubuntu.com/singlehtml/&#34;&gt;Ubuntu Packaging Guide&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=nhoRyd2CEVs&#34;&gt;How to build a simple Debian package (*.Deb) - YouTube&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.debian.org/doc/manuals/maint-guide/&#34;&gt;Debian New Maintainers’ Guide&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.debian.org/doc/manuals/packaging-tutorial/packaging-tutorial.en.pdf&#34;&gt;Packaging tutorial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;End.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TButton 命令行快捷按钮</title>
      <link>http://neilsh.me/2016/01/20/tbutton-mini-commands-launcher/</link>
      <pubDate>Wed, 20 Jan 2016 12:02:36 +0800</pubDate>
      
      <guid>http://neilsh.me/2016/01/20/tbutton-mini-commands-launcher/</guid>
      <description>&lt;p&gt;众所周知 Linux 的命令行十分强大，一些图形化操作很麻烦的事情，在命令行里敲击下几下键盘就能搞定。
比如说，在虚拟机里跑 windows，用 word 来写一些报告，但是资料收集是在 Ubuntu 里做的，在收集资料的时候又不想让虚拟机空耗着 CPU。这时我们可以在命令行里输入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;killall -s STOP vmware-vmx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;过不了多久，之前还呼啸的风扇现在已经没声音了。要恢复被暂停的虚拟机也非常简单，只要输入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;killall -s CONT vmware-vmx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果用图形化来暂停虚拟机的话，需要打开 System Monitor 点击 Processes 标签，在几百个进程中找到 vmware-vmx，右击出现菜单，点击 Stop Process。擅长用户交互的图形化界面在这种事前羸弱不堪。&lt;/p&gt;

&lt;p&gt;不过经常敲键盘也确实挺烦人的，能不能做一个快捷方式，鼠标点一下就行了呢？我在网上找了一圈，并没有发现现成的解决方案，又是自己动手丰衣足食的节奏，于是就有了 &lt;a href=&#34;https://github.com/overvenus/tbutton&#34;&gt;&lt;strong&gt;TButton&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TButton&lt;/strong&gt; 是用 Python 写的，做做很快，没花多长时间。参考了 &lt;a href=&#34;https://github.com/phuslu/goproxy/blob/master/assets/gui/goagent-gtk.py&#34;&gt;goagent-gtk&lt;/a&gt;
开源在 &lt;em&gt;&lt;a href=&#34;https://github.com/overvenus/tbutton&#34;&gt;https://github.com/overvenus/tbutton&lt;/a&gt;&lt;/em&gt;
昨天我做了一个安装包，&lt;a href=&#34;https://github.com/overvenus/tbutton/releases&#34;&gt;戳这下载&lt;/a&gt;。或者从我的 PPA 安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo add-apt-repository ppa:overvenus/ppa
sudo apt-get update
sudo apt-get install indicator-tbutton
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;目前的功能还很简单，就只有“点击 &amp;ndash;&amp;gt; 执行”，对应的命令要在配置文件中写好，配置文件在 &lt;code&gt;~/.config/Tbutton/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;下面是 TButton 在我电脑上的使用效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/overvenus/tbutton/master/art/TbuttonScr.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;PS：这个小玩具其实早想写了，但总是迟迟不肯动手，这不趁复习周看书看烦了，赶紧写一下，不然看书都没效率了（逃。。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2015年总结</title>
      <link>http://neilsh.me/2015/12/31/summary-2015/</link>
      <pubDate>Thu, 31 Dec 2015 11:12:58 +0800</pubDate>
      
      <guid>http://neilsh.me/2015/12/31/summary-2015/</guid>
      <description>

&lt;h2 id=&#34;公开课:f7f78efa2947b615033306c6fc2dd7d2&#34;&gt;公开课&lt;/h2&gt;

&lt;p&gt;2015 年，我自学了 6.006，6.033，6.828 和 6.824，选择这几门课主要是补计算机的基础知识。
等等 6.824 不是 Graduate 课程吗？管他呢，学了再说。(・ε・) 虽说现在还没有学完，但个人感觉这门课并不比前面的 6.828 难。最近临近期末，得暂时放一放，考试周结束后接着学。
论文看了不少，大部分是这几门课中要求的，小部分是自己找来的，大都关于操作系统和分布式系统。&lt;/p&gt;

&lt;h2 id=&#34;项目:f7f78efa2947b615033306c6fc2dd7d2&#34;&gt;项目&lt;/h2&gt;

&lt;p&gt;JOS: 类 UNIX 的操作系统内核，6.828 配套的实验项目，我在这个项目中&lt;a href=&#34;http://neilsh.me/2015/08/30/few_words_about_6_828/&#34;&gt;学到了很多&lt;/a&gt;。
其他的几个小项目倒更像是玩具，不在这显摆了。&lt;/p&gt;

&lt;h2 id=&#34;阅读:f7f78efa2947b615033306c6fc2dd7d2&#34;&gt;阅读&lt;/h2&gt;

&lt;p&gt;在 2015 一年里，书看得不是很多。我很难想象别人是怎么看完那长长的书单的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;《C和指针》 Kenneth A. Reek&lt;/li&gt;
&lt;li&gt;《算法导论》前四章 Thomas H.Cormen, Charles E.Leiserson, Ronald L.Rivest, Clifford Stein&lt;/li&gt;
&lt;li&gt;《计算机系统设计原理》 Jerome H. Saltzer, M. Frans Kaashoek&lt;/li&gt;
&lt;li&gt;《现代操作系统》 Andrew S. Tanenbaum&lt;/li&gt;
&lt;li&gt;《Structured Computer Organization》 Andrew S. Tanenbaum&lt;/li&gt;
&lt;li&gt;《深入理解计算机系统》 Randal E.Bryant, David R.O&amp;rsquo;Hallaron&lt;/li&gt;
&lt;/ul&gt;

&lt;hr/&gt;

&lt;ul&gt;
&lt;li&gt;《如何阅读一本书》 莫提默·J. 艾德勒 查尔斯·范多伦&lt;/li&gt;
&lt;li&gt;《民主的细节》 刘瑜&lt;/li&gt;
&lt;li&gt;《黑客与画家》 Paul Graham&lt;/li&gt;
&lt;li&gt;《三体》 刘慈欣&lt;/li&gt;
&lt;li&gt;《百年孤独》 加西亚·马尔克斯 著 范晔 译&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;论文：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Belay, Adam, Andrea Bittau, and Ali Mashtizadeh. 2012. “Dune: Safe User-Level Access to Privileged Cpu Features.” OSDI ’12: Proceedings of the 10th USENIX Conference on Operating Systems Design and Implementation, 335–48. &lt;a href=&#34;https://www.usenix.org/system/files/conference/osdi12/osdi12-final-117.pdf&#34;&gt;https://www.usenix.org/system/files/conference/osdi12/osdi12-final-117.pdf&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Belay, Adam, George Prekas, Ana Klimovic, Samuel Grossman, Christos Kozyrakis, and Edouard Bugnion. 2014. “IX: A Protected Dataplane Operating System for High Throughput and Low Latency.” Proceedings of the 11th USENIX Conference on Operating Systems Design and Implementation, 49–65. &lt;a href=&#34;http://dl.acm.org/citation.cfm?id=2685048.2685053&#34;&gt;http://dl.acm.org/citation.cfm?id=2685048.2685053&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Boyd-wickizer, Silas, M Frans Kaashoek, Robert Morris, and Nickolai Zeldovich. 2012. “Non-Scalable Locks Are Dangerous.” Proceedings of the Linux Symposium. &lt;a href=&#34;http://ns1.fs.net/papers/linux:lock.pdf&#34;&gt;http://ns1.fs.net/papers/linux:lock.pdf&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Clements, Austin T, M Frans Kaashoek, and Nickolai Zeldovich. 2013. “RadixVM : Scalable Address Spaces for Multithreaded Applications.” EuroSys, 211–24. doi:10.&lt;sup&gt;1145&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2465351&lt;/sub&gt;.2465373.&lt;/li&gt;
&lt;li&gt;Engler, D R, M F Kaaspoek, and J O’Toole. 1995. “ExoKernel: An Operating System Architecture for Application Level Resource Management.” Proceedings of the 15th ACM Symposium on Operating System Principles 1 (212): 256–66. doi:&lt;a href=&#34;http://doi.acm.org/10.1145/224056.224076&#34;&gt;http://doi.acm.org/10.1145/224056.224076&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Hunt, Galen C, and James R Larus. 2007. “Singularity: Rethinking the Software Stack.” Contract 41 (2): 37–49. doi:10.&lt;sup&gt;1145&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1243418&lt;/sub&gt;.1243424.&lt;/li&gt;
&lt;li&gt;Kivity, Avi, Uri Lublin, Anthony Liguori, Yaniv Kamay, and Dor Laor. 2007. “Kvm: The Linux Virtual Machine Monitor.” Proceedings of the Linux Symposium 1: 225–30. &lt;a href=&#34;https://www.kernel.org/doc/mirror/ols2007v1.pdf#page=225&#34;&gt;https://www.kernel.org/doc/mirror/ols2007v1.pdf#page=225&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Ritchie, D M, and K Thompson. 1974. “The UNIX Time-Sharing System.” Communications of the ACM 17 (7): 365–75.&lt;/li&gt;
&lt;li&gt;Ritchie, Dm. 1984. “The Evolution of the Unix Time-Sharing System.” AT&amp;amp;T Bell Laboratories Technical Journal 63 (6): 1577–93. doi:10.&lt;sup&gt;1007&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt;-540-09745-7_2.&lt;/li&gt;
&lt;li&gt;Simon, Herbert A, Philosophical Society, and No Dec. 2007. “The Architecture of Complexity” 106 (6): 467–82. doi:10.&lt;sup&gt;2307&lt;/sup&gt;&amp;frasl;&lt;sub&gt;985254&lt;/sub&gt;.&lt;/li&gt;
&lt;li&gt;Tang, Shuo, Haohui Mai, and S.T. King. 2010. “Trust and Protection in the Illinois Browser Operating System.” Proceedings of the 9th USENIX Symposium on Operating Systems Design and Implementation (OSDI ’10), no. October: 17–31. &lt;a href=&#34;http://www.usenix.org/events/osdi10/tech/full_papers/Tang.pdf&#34;&gt;http://www.usenix.org/events/osdi10/tech/full_papers/Tang.pdf&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Bolosky, William J, Dexter Bradshaw, Randolph B Haagens, Norbert P Kusters, and Peng Li. 2011. “Paxos Replicated State Machines as the Basis of a High-Performance Data Store 2 . Paxos Replicated State Ma- Chines.” System, 11.&lt;/li&gt;
&lt;li&gt;Cao, P, E Felten, and K Li. 1994. “Implementation and Performance of Application-Controlled File Caching.” Proceedings of the First Symposium on Operating Systems Design and Implementation, 165–78. citeseer.ifi.unizh.ch/cao94implementation.html.&lt;/li&gt;
&lt;li&gt;Chandra, Tushar, Robert Griesemer, and Joshua Redstone. 2007a. “Paxos Made Live - An Engineering Perspective ( 2006 Invited Talk ).” Perspective 7: 398–407. doi:10.&lt;sup&gt;1145&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1281100&lt;/sub&gt;.1281103.&lt;/li&gt;
&lt;li&gt;Tushar Chandra, Robert Griesemer, and Joshua Redstone. 2007b. “Paxos Made Live: An Engineering Perspective.” Proceedings of the Twenty-Sixth Annual ACM Symposium on Principles of Distributed Computing, 398–407. doi:10.&lt;sup&gt;1145&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1281100&lt;/sub&gt;.1281103.&lt;/li&gt;
&lt;li&gt;Corbett, James C, Jeffrey Dean, Michael Epstein, Andrew Fikes, Christopher Frost, J J Furman, Sanjay Ghemawat, et al. 2012. “Spanner : Google ’ S Globally-Distributed Database.” Proceedings of OSDI 2012, 1–14. doi:10.&lt;sup&gt;1145&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2491245&lt;/sub&gt;.&lt;/li&gt;
&lt;li&gt;Cully, Brendan, Geoffrey Lefebvre, and Dutch Meyer. 2008. “Remus: High Availability via Asynchronous Virtual Machine Replication.” Proceedings of the 5th … vi: 161–74. &lt;a href=&#34;http://portal.acm.org/citation.cfm?id=1387589.1387601nhttp://www.usenix.org/event/nsdi08/tech/full_papers/cully/cully_html/&#34;&gt;http://portal.acm.org/citation.cfm?id=1387589.1387601nhttp://www.usenix.org/event/nsdi08/tech/full_papers/cully/cully_html/&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Dean, Jeffrey, and Sanjay Ghemawat. n.d. “MapReduce : Simplified Data Processing on Large Clusters,” 137–49.&lt;/li&gt;
&lt;li&gt;Fischer, Michael J., Nancy A. Lynch, and Michael S. Paterson. 1985. “Impossibility of Distributed Consensus with One Faulty Process.” Journal of the ACM 32 (2): 374–82. doi:10.&lt;sup&gt;1145&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3149&lt;/sub&gt;.214121.&lt;/li&gt;
&lt;li&gt;Hunt, Patrick, Mahadev Konar, Fp Junqueira, and Benjamin Reed. 2010. “ZooKeeper: Wait-Free Coordination for Internet-Scale Systems.” USENIX Annual Technical … 8: 11–11. &lt;a href=&#34;http://portal.acm.org/citation.cfm?id=1855851nhttps://www.usenix.org/event/usenix10/tech/full_papers/Hunt.pdf&#34;&gt;http://portal.acm.org/citation.cfm?id=1855851nhttps://www.usenix.org/event/usenix10/tech/full_papers/Hunt.pdf&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Lamport, Leslie. 2001. “Paxos Made Simple.” ACM SIGACT News 32 (4): 51–58. doi:10.&lt;sup&gt;1145&lt;/sup&gt;&amp;frasl;&lt;sub&gt;568425&lt;/sub&gt;.568433.&lt;/li&gt;
&lt;li&gt;Liskov, Barbara, and James Cowling. 2012. “Viewstamped Replication Revisited,” no. MIT-CSAIL-TR-2012-021: 1–14.&lt;/li&gt;
&lt;li&gt;Liskov, Barbara, Sanjay Ghemawat, Robert Gruber, Paul Johnson, and Liuba Shrira. 1991. “Replication in the Harp File System.” ACM SIGOPS Operating Systems Review 25: 226–38. doi:10.&lt;sup&gt;1145&lt;/sup&gt;&amp;frasl;&lt;sub&gt;121133&lt;/sub&gt;.121169.&lt;/li&gt;
&lt;li&gt;Nightingale, Edmund B., Jeremy Elson, and Jinliang Fan. 2012. “Flat Datacenter Storage.” OSDI’12 Proceedings of the 10th USENIX Conference on Operating Systems Design and Implementation, 1–15. &lt;a href=&#34;https://www.usenix.org/system/files/conference/osdi12/osdi12-final-75.pdf&#34;&gt;https://www.usenix.org/system/files/conference/osdi12/osdi12-final-75.pdf&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Drepper, Ulrich. 2007. “What Every Programmer Should Know about Memory.” Red Hat, Inc 3: 114. doi:10.1.1.91.957.&lt;/li&gt;
&lt;li&gt;Fähndrich, Manuel, Mark Aiken, Chris Hawblitzel, Orion Hodson, Galen Hunt, James R. Larus, and Steven Levi. 2006. “Language Support for Fast and Reliable Message-Based Communication in Singularity OS.” ACM SIGOPS Operating Systems Review 40 (4): 177. doi:10.&lt;sup&gt;1145&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1218063&lt;/sub&gt;.1217953.&lt;/li&gt;
&lt;li&gt;Mellor-crummey, John M, and Michael L Scott. 1991. “Calable Synchronization on.” Computer 9 (1): 21–65. doi:10.&lt;sup&gt;1145&lt;/sup&gt;&amp;frasl;&lt;sub&gt;103727&lt;/sub&gt;.103729.&lt;/li&gt;
&lt;li&gt;Patterson, David a., Garth Gibson, and Randy H. Katz. 1988. “A Case for Redundant Arrays of Inexpensive Disks (RAID).” ACM SIGMOD Record 17 (3): 109–16. doi:10.&lt;sup&gt;1145&lt;/sup&gt;&amp;frasl;&lt;sub&gt;971701&lt;/sub&gt;.50214.&lt;/li&gt;
&lt;li&gt;Saltzer, J. H., D. P. Reed, and D. D. Clark. 1984. “End-to-End Arguments in System Design.” ACM Transactions on Computer Systems 2 (4): 277–88. doi:10.&lt;sup&gt;1145&lt;/sup&gt;&amp;frasl;&lt;sub&gt;357401&lt;/sub&gt;.357402.&lt;/li&gt;
&lt;li&gt;Savage, Stefan, Michael Burrows, Greg Nelson, Patrick Sobalvarro, and Thomas Anderson. 1997. “Eraser: A Dynamic Data Race Detector for Multithreaded Programs.” ACM Transactions on Computer Systems 15 (4): 391–411. doi:10.&lt;sup&gt;1145&lt;/sup&gt;&amp;frasl;&lt;sub&gt;265924&lt;/sub&gt;.265927.&lt;/li&gt;
&lt;li&gt;Tweedie, SC. 1998. “Journaling the Linux ext2fs Filesystem.” The Fourth Annual Linux Expo, 1–8. &lt;a href=&#34;http://www.stanford.edu/class/cs240/readings/ext2-journal-design.pdf&#34;&gt;http://www.stanford.edu/class/cs240/readings/ext2-journal-design.pdf&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Uhlig, Rich, Gil Neiger, Dion Rodgers, Amy L. Santoni, Fernando C M Martins, Andrew V. Anderson, Steven M. Bennett, Alain Kägi, Felix H. Leung, and Larry Smith. 2005. “Intel Virtualization Technology.” Computer 38 (5): 48–56. doi:10.1109/MC.2005.163.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;值得一提:f7f78efa2947b615033306c6fc2dd7d2&#34;&gt;值得一提&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在 StackOverflow 回答了第一个问题，并被接受！&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://ww3.sinaimg.cn/large/7f793092gw1ezitciklpaj20gf0cqjv1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Github 第一个 Pull Requset，并被合并。我为科学计算界做出了贡献！ (΄◞ิ౪◟ิ‵)&lt;/li&gt;
&lt;li&gt;第一份实习，简历有点料了！&lt;/li&gt;
&lt;li&gt;建立了这个博客！&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;总结与展望:f7f78efa2947b615033306c6fc2dd7d2&#34;&gt;总结与展望&lt;/h2&gt;

&lt;p&gt;总的来说，我在 2015 年过得很充实，对自己的表现也很满意。有得必有失，这一年我长期呆在实验室里，闷头看书学习，户外活动急剧减少，2014 年坚持的跑步也在今年放弃了，起初安慰自己没时间，有雾霾，但真的是这样吗？时间就像海绵里的水，只要你愿意挤，总还是有的。雾霾天跑步诚然不利于健康，但也不会天天都是。
2016 年，我希望自己在保持这股子学习劲儿的同时还要恢复户外锻炼的习惯，就酱。&lt;/p&gt;

&lt;p&gt;完。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>最小二乘法的矩阵形式</title>
      <link>http://neilsh.me/2015/12/25/least-square-in-matrix/</link>
      <pubDate>Fri, 25 Dec 2015 10:10:28 +0800</pubDate>
      
      <guid>http://neilsh.me/2015/12/25/least-square-in-matrix/</guid>
      <description>

&lt;h2 id=&#34;拟合曲线与最小二乘法:7da2dc83c8d8e9ad8c6717b64208ddaf&#34;&gt;拟合曲线与最小二乘法&lt;/h2&gt;

&lt;p&gt;曲线拟合指：已知 m 个数据点 $(x_i,y_i ),i=1,2,3⋯,m$ 其中 m 不全相同，寻求函数 $f(x; \beta_0, \beta_1, \dots, \beta_n)$ 的待定参数 $\beta_0, \beta_1, \dots, \beta_n$ 的一组取值，使得在这组取值之下，函数 $f(x; \beta_0, \beta_1, \dots,\beta_n)$ 与已知 m 个数据点整体上最为接近。&lt;/p&gt;

&lt;p&gt;最小二乘曲线拟合方法：根据已知数据，首先构造出能够反映含有回归参数的回归方程 $f(x; \beta_i),i = 0, 1, 2, …, n$ :&lt;/p&gt;

&lt;p&gt;$$
\begin{align}
\hat{y} &amp;amp;= \beta_0 + \beta_1 x + \beta_2 x^2 + \dots + \beta_n x^n \\
y &amp;amp;= \hat{y} + \delta
\end{align}
$$&lt;/p&gt;

&lt;p&gt;$\delta$ 是残差，这是回归方程与真实值存在出入的原因[1]。&lt;/p&gt;

&lt;p&gt;根据 m 个数据点 $(x_i, y_i),i=1,2,3⋯,m$ 可以定义一个代表偏离程度的函数:&lt;/p&gt;

&lt;p&gt;$$
S(\beta_0, \beta_1, \dots, \beta_n) = \sum_{j = 1}^m [y_i - f(x; \beta_0, \beta_1, \dots,\beta_n)]^2 = \sum \delta
$$&lt;/p&gt;

&lt;p&gt;当 $S(\beta_0, \beta_1, \dots,\beta_n)$ 取得最小值时，此时的 $\beta_0, \beta_1, \dots,\beta_n$ 即为回归方程的回归系数，也是最小二乘解。&lt;/p&gt;

&lt;h2 id=&#34;最小二乘矩阵形式:7da2dc83c8d8e9ad8c6717b64208ddaf&#34;&gt;最小二乘矩阵形式&lt;/h2&gt;

&lt;p&gt;多组测量数据 $(x_i,y_i),i=1,2,3⋯,m$ 可以构成两个行列式[2]：&lt;/p&gt;

&lt;p&gt;$$ X=\begin{bmatrix} x_1 \\ x_2 \\ x_3 \\ \vdots \\ x_m \end{bmatrix}, Y=\begin{bmatrix} y_1 \\ y_2 \\ y_3 \\ \vdots \\ y_m \end{bmatrix} $$&lt;/p&gt;

&lt;p&gt;将多组数据代入到回归方程 $f$ 后，可得：&lt;/p&gt;

&lt;p&gt;$$
Y = \beta_0 + \beta_1 X + \beta_2 X^2 + \dots + \beta_n X^n + \Delta
$$&lt;/p&gt;

&lt;p&gt;$$
\Delta = \begin{bmatrix}
\delta_1 \\ \delta_2 \\ \delta_3 \\ \vdots \\ \delta_m
\end{bmatrix} , \beta=\begin{bmatrix}
\beta_0 \\ \beta_1 \\ \vdots \\ \beta_n
\end{bmatrix}
$$&lt;/p&gt;

&lt;p&gt;再将 X 的转化为范德蒙德行列式：&lt;/p&gt;

&lt;p&gt;$$
V=\begin{bmatrix}
1 &amp;amp; x_1 &amp;amp; x_1^2 &amp;amp; \dots &amp;amp; x_1^{n} \\
1 &amp;amp; x_2 &amp;amp; x_2^2 &amp;amp; \dots &amp;amp; x_2^{n} \\
1 &amp;amp; x_3 &amp;amp; x_3^2 &amp;amp; \dots &amp;amp; x_3^{n} \\
\vdots &amp;amp; \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp;\vdots \\
1 &amp;amp; x_m &amp;amp; x_m^2 &amp;amp; \dots &amp;amp; x_m^{n}
\end{bmatrix}
$$&lt;/p&gt;

&lt;p&gt;综上，可得：
$$
V\beta \approx Y \Rightarrow \Delta = \hat{Y} - Y = V\beta - Y
$$&lt;/p&gt;

&lt;p&gt;$\hat{Y}$ 为 $\hat{y_i}$构成的列向量。&lt;/p&gt;

&lt;p&gt;因为 $\Delta$ 的范数: $\Vert \Delta \Vert = \left( \sum_{i = 1}^m \delta_i^2 \right)^\frac{1}2$，所以求最小二乘解即可转化为如何使 $\Delta$ 的范数最小。&lt;/p&gt;

&lt;p&gt;$$
\Vert \Delta \Vert^2  = \sum{\delta_i^2}
                      = \begin{bmatrix}
                         \delta_1 \delta_2 \dots \delta_n
                        \end{bmatrix} \begin{bmatrix}\delta_1 \\
                                                     \delta_2 \\
                                                     \vdots \\
                                                     \delta_n
                                      \end{bmatrix}
                      = \delta^T \delta
$$&lt;/p&gt;

&lt;p&gt;$$
\Vert \Delta \Vert^2 = \Vert Y - V\beta \Vert^2 = \left( Y - V\beta \right)^T\left( Y - V\beta \right)
$$&lt;/p&gt;

&lt;h2 id=&#34;最小二乘矩阵算法:7da2dc83c8d8e9ad8c6717b64208ddaf&#34;&gt;最小二乘矩阵算法&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Let the scalar $\alpha$ be defined by
$$\alpha = Y^T X$$
where Y is n × 1, X is n × 1, and both Y and X are functions of the vector z. Then
$$\frac{d(\alpha)}{d(z)} = X^T\frac{d(Y)}{d(z)}+Y^T\frac{d(X)}{d(z)}$$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;根据上面定理，可得：
$$
\frac{d\Delta}{d\beta} = \frac{d}{d\beta}\left(\left( Y - V\beta \right)^T\left( Y - V\beta \right)\right) = -2V^T\left(Y-V\beta\right)
$$&lt;/p&gt;

&lt;p&gt;为使 $\Delta$ 最小，可使 $\frac{d\Delta}{d\beta} = 0 \Rightarrow -2V^T\left(Y-V\beta\right) = 0$。&lt;/p&gt;

&lt;p&gt;目前常见的算法有三种：Normal equations，QR-Factorization 和 SVD。&lt;/p&gt;

&lt;!--
这三个算法应用在计算机中时，有几点需要注意：
 1. 计算机中，浮点数的精度有限，当数过小时，就成0.
 2. 
--&gt;

&lt;!--
TOOD: 
 0. 是否可逆，奇异矩阵
 1. 计算机精度问题
 2. 算法稳定问题
--&gt;

&lt;h3 id=&#34;normal-equations:7da2dc83c8d8e9ad8c6717b64208ddaf&#34;&gt;Normal equations&lt;/h3&gt;

&lt;p&gt;$$
\begin{align}
-2V^T\left(Y-V\beta\right) &amp;amp;= 0\\
V^T V\beta &amp;amp;= V^TY \\
\beta &amp;amp;= \left(V^T V\right)^{-1}V^T Y
\end{align}
$$
这个算法的时间复杂度最小，计算 $\beta$ 速度最快。但是在计算机中，浮点数的精度有限，当某些矩阵中的数过小时，就算该矩阵是满秩的非奇异的，但在计算机中，该矩阵就是奇异矩阵。
这个问题在 Normal equations 尤为严重[2]。比如下面矩阵 D：
$$
\begin{align}
D &amp;amp;= \begin{bmatrix}
1 &amp;amp; 1 \\
0 &amp;amp; \delta \\
\delta &amp;amp; 0 \\
\end{bmatrix}, |\delta| = 1 \times \text{Minimum precision} \\
D^T D &amp;amp;= \begin{bmatrix}
1+\delta^2 &amp;amp; 1 \\
1 &amp;amp; 1+\delta^2
\end{bmatrix}
\end{align}
$$
这个算法出现了 $\delta^2$，容易出现奇异矩阵，所以不稳定。&lt;/p&gt;

&lt;h3 id=&#34;qr-factorization:7da2dc83c8d8e9ad8c6717b64208ddaf&#34;&gt;QR-Factorization&lt;/h3&gt;

&lt;p&gt;QR-Factorization 要比 Normal equations 稳定。
这个算法先把 $V$ 进行 QR 分解[&lt;a href=&#34;https://en.wikipedia.org/wiki/QR_decomposition#Using_for_solution_to_linear_inverse_problems&#34;&gt;3&lt;/a&gt;]: $QR = V$
$$
\begin{align}
V^T V \beta &amp;amp;= V^T Y \\
(QR)^T Q R \beta &amp;amp;= (Q R)^T Y \\
R^T Q^T Q R \beta &amp;amp;= R^T Q^T Y \\
R^T R \beta &amp;amp;= R^T Q^T Y \\
R\beta &amp;amp;= Q^T Y \\
\beta &amp;amp;= R^{-1} Q^T Y
\end{align}
$$
由于 R 是一个上三角矩阵，所以求解很方便。这个也是 Matlab 中&lt;code&gt;polyfit&lt;/code&gt;合的算法[2]。&lt;/p&gt;

&lt;h2 id=&#34;参考文献:7da2dc83c8d8e9ad8c6717b64208ddaf&#34;&gt;参考文献&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;[1] Chatterjee, Samprit, Ali S. Hadi, and Bertram Price. 2000. Regression analysis by example. New York: Wiley.&lt;/p&gt;

&lt;p&gt;[2] Moler, Cleve B. Numerical Computing with MATLAB: Revised Reprint. Siam, 2008.&lt;/p&gt;

&lt;p&gt;[3] Wikipedia contributors, &amp;ldquo;QR decomposition,&amp;rdquo; Wikipedia, The Free Encyclopedia, &lt;a href=&#34;https://en.wikipedia.org/wiki/QR_decomposition#Using_for_solution_to_linear_inverse_problems&#34;&gt;https://en.wikipedia.org/wiki/QR_decomposition#Using_for_solution_to_linear_inverse_problems&lt;/a&gt; (accessed November 23, 2015).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!-- Links --&gt;
</description>
    </item>
    
    <item>
      <title>解除尔雅公开课暂停</title>
      <link>http://neilsh.me/2015/11/29/erya-no-pause/</link>
      <pubDate>Sun, 29 Nov 2015 22:04:04 +0800</pubDate>
      
      <guid>http://neilsh.me/2015/11/29/erya-no-pause/</guid>
      <description>

&lt;h2 id=&#34;恶心的暂停:e99fde2bd1ab83d1dc4d02061c03ef67&#34;&gt;恶心的暂停&lt;/h2&gt;

&lt;p&gt;这学期，我参加了尔雅公开课，要完成公开课必须先看完课程视频，但是在看视频的时候，尔雅会限制电脑的当前窗口必须为浏览器，否则暂停。本来公开课要求看完视频，这并不过分，但是非要加上这么个限制，我的黑客心就不安份了。 :-P&lt;/p&gt;

&lt;h2 id=&#34;过程:e99fde2bd1ab83d1dc4d02061c03ef67&#34;&gt;过程&lt;/h2&gt;

&lt;p&gt;对于尔雅的这个限制，我的第一反应是 js 事件监听。js 的事件这么多，难道要一个个翻过去吗？NO, NO, NO. 去年火狐推出的新功能[&lt;a href=&#34;https://hacks.mozilla.org/2014/07/event-listeners-popup-media-sidebar-cubic-bezier-editor-more-firefox-developer-tools-episode-33/&#34;&gt;1&lt;/a&gt;]，使查看 js 事件监听变得极为容易。两三下功夫就找到了一个可疑的事件，见下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ww2.sinaimg.cn/large/7f793092gw1eyp26kv1jpj20v50cxtd8.jpg&#34; alt=&#34;&#34; /&gt;
这个函数中的&lt;code&gt;pauseMovie()&lt;/code&gt;基本就确定是这个搞得鬼了。为了进一步确定，我在 console 输入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(&#39;#eryaPlayer&#39;).pauseMovie();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;视频就暂停了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/7f793092gw1eyp1u6wek1j20ga0c40v5.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;再输入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;window.onblur = null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面命令执行完之后，暂停的限制就解除了。 LOL&lt;/p&gt;

&lt;h2 id=&#34;脚本:e99fde2bd1ab83d1dc4d02061c03ef67&#34;&gt;脚本&lt;/h2&gt;

&lt;p&gt;我并没有学过 js，只能照葫芦画瓢，根据官方文档来写[&lt;a href=&#34;http://wiki.greasespot.net/Greasemonkey_Manual&#34;&gt;2&lt;/a&gt;]。如果哪里出错或写的不好，欢迎提出来。&lt;/p&gt;

&lt;p&gt;Firefox + Greasemonkey[&lt;a href=&#34;https://addons.mozilla.org/en-US/firefox/addon/greasemonkey/&#34;&gt;3&lt;/a&gt;]，把脚本拖入浏览器即使用。&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/Overvenus/c41a34f7e039b9207210.js&#34;&gt;&lt;/script&gt;

&lt;h2 id=&#34;已知问题:e99fde2bd1ab83d1dc4d02061c03ef67&#34;&gt;已知问题&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;无法去除随机暂停及验证码暂停。&lt;/li&gt;
&lt;li&gt;Chrome 无法使用。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;链接:e99fde2bd1ab83d1dc4d02061c03ef67&#34;&gt;链接&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;[1]: &lt;a href=&#34;https://hacks.mozilla.org/2014/07/event-listeners-popup-media-sidebar-cubic-bezier-editor-more-firefox-developer-tools-episode-33/&#34;&gt;Event listeners popup, @media sidebar, Cubic bezier editor + more – Firefox Developer Tools Episode 33&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2]: &lt;a href=&#34;http://wiki.greasespot.net/Greasemonkey_Manual&#34;&gt;Greasemonkey Manual - GreaseSpot Wiki&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[3]: &lt;a href=&#34;https://addons.mozilla.org/en-US/firefox/addon/greasemonkey/&#34;&gt;Greasemonkey :: Add-ons for Firefox&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;End.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>paxos digest</title>
      <link>http://neilsh.me/2015/11/25/paxos-digest/</link>
      <pubDate>Wed, 25 Nov 2015 19:25:23 +0800</pubDate>
      
      <guid>http://neilsh.me/2015/11/25/paxos-digest/</guid>
      <description>

&lt;h2 id=&#34;paxos:8aa297440e030e6ae04600c7109020a5&#34;&gt;Paxos&lt;/h2&gt;

&lt;p&gt;Paxos is one of the most important algorithms in distributed system.[&lt;a href=&#34;http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf&#34;&gt;1&lt;/a&gt;]
Here are some notes about Basic Paxos.&lt;/p&gt;

&lt;h2 id=&#34;three-roles-in-paxos:8aa297440e030e6ae04600c7109020a5&#34;&gt;Three roles in Paxos&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Proposers&lt;/li&gt;
&lt;li&gt;Acceptor&lt;/li&gt;
&lt;li&gt;Learners&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;General view:  &lt;strong&gt;&lt;em&gt;Proposers&lt;/em&gt;&lt;/strong&gt; send proposals to &lt;strong&gt;&lt;em&gt;Acceptors&lt;/em&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;Acceptors&lt;/em&gt;&lt;/strong&gt; accept a proposal and forward to &lt;strong&gt;&lt;em&gt;Learners&lt;/em&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;Learners&lt;/em&gt;&lt;/strong&gt; decided the proposal.
In real world, a single server acts &lt;strong&gt;two or more&lt;/strong&gt; roles.&lt;/p&gt;

&lt;h2 id=&#34;requirements:8aa297440e030e6ae04600c7109020a5&#34;&gt;Requirements&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;An acceptor must accept the first proposal that it receives.
1a. An acceptor can accept a proposal numbered n iff it has not responded to a prepare request having a number greater than n.&lt;/li&gt;
&lt;li&gt;If a proposal with value v is chosen, then every higher-numbered proposal that is chosen has value v.
2a. If a proposal with value v is chosen, then every higher-numbered proposal accepted by any acceptor has value v.
2b. If a proposal with value v is chosen, then every higher-numbered proposal issued by any proposer has value v.
2c. For any v and n, if a proposal with value v and number n is issued, then there is a set S consisting of a majority of acceptors such that either (a) no acceptor in S has accepted any proposal numbered less than n, or (b) v is the value of the highest-numbered proposal among all proposals numbered less than n accepted by the acceptors in S.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1a is stronger then 1, and 2c =&amp;gt; 2b =&amp;gt; 2a =&amp;gt; 2.&lt;/p&gt;

&lt;h2 id=&#34;rpcs-and-phases:8aa297440e030e6ae04600c7109020a5&#34;&gt;RPCs and Phases&lt;/h2&gt;

&lt;p&gt;Proposers send two kinds of RPC to &lt;strong&gt;majority&lt;/strong&gt; Acceptors.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;Prepare&lt;/em&gt;, send with a uniqe proposal number n.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Accept&lt;/em&gt;, send with a uniqe proposal number n and proposal value v.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There are two phases in Paxos.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Phase 1: broadcast &lt;em&gt;Prepare&lt;/em&gt; RPC&lt;/li&gt;
&lt;li&gt;Phase 2: broadcast &lt;em&gt;Accept&lt;/em&gt; RPC&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Majority is the key to achieve consensus and correctness.&lt;/p&gt;

&lt;h2 id=&#34;implementation:8aa297440e030e6ae04600c7109020a5&#34;&gt;Implementation&lt;/h2&gt;

&lt;p&gt;Every server play all roles (proposer, acceptor, and learner) in every instance of the algorithm. For a normal operation, there will be a server being elected to act the &lt;strong&gt;leader&lt;/strong&gt;, which is the distinguished proposer (the &lt;strong&gt;only one&lt;/strong&gt; that tries to issue proposals) in all instances of the algorithm.&lt;/p&gt;

&lt;h2 id=&#34;pseudo-code:8aa297440e030e6ae04600c7109020a5&#34;&gt;Pseudo code&lt;/h2&gt;

&lt;p&gt;Handout of 6.824, Spring 2015 [&lt;a href=&#34;http://nil.csail.mit.edu/6.824/2015/notes/paxos-code.html&#34;&gt;2&lt;/a&gt;]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      --- Paxos Proposer ---

      proposer(v):
        while not decided:
          choose n, unique and higher than any n seen so far
          send prepare(n) to all servers including self
          if prepare_ok(n, na, va) from majority:       --- na and nv is proposal number and value (if any) that acceptor has accepted.
            v&#39; = va with highest na; choose own v otherwise   
            send accept(n, v&#39;) to all
            if accept_ok(n) from majority:              --- Paxos Learner ---
              send decided(v&#39;) to all


      --- Paxos Acceptor ---

      acceptor state on each node (persistent):
       np     --- highest prepare seen
       na, va --- highest accept seen

      acceptor&#39;s prepare(n) handler:
       if n &amp;gt; np
         np = n
         reply prepare_ok(n, na, va)
       else
         reply prepare_reject


      acceptor&#39;s accept(n, v) handler:
       if n &amp;gt;= np
         np = n
         na = n
         va = v
         reply accept_ok(n)
       else
         reply accept_reject
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;examples:8aa297440e030e6ae04600c7109020a5&#34;&gt;Examples&lt;/h2&gt;

&lt;p&gt;Servers and proposal vaule: S1(X)
Prepare: P,1
Accept: A,1,X&lt;/p&gt;

&lt;h3 id=&#34;e-g-1:8aa297440e030e6ae04600c7109020a5&#34;&gt;E.g. 1&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;S1(X)    P,1    A,1,X
S2
S3       P,1    A,1,X
                    ^ chosen
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;X is chosen.&lt;/p&gt;

&lt;h3 id=&#34;e-g-2:8aa297440e030e6ae04600c7109020a5&#34;&gt;E.g. 2&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;S1(X)    P,1    A,1,X
S2       P,1    A,1,X    P,3    A,3,X
S3(Y)                    P,3    A,3,X
                    ^ chosen
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;X is chosen.
S2 response &lt;code&gt;P,3&lt;/code&gt; with &lt;code&gt;1,X&lt;/code&gt;, S3 send proposal value X instead of Y.&lt;/p&gt;

&lt;h3 id=&#34;e-g-3:8aa297440e030e6ae04600c7109020a5&#34;&gt;E.g. 3&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;S1(X)    P,1    A,1,X
S2       P,1             P,3    A,3,Y    A,1,X(rej)
S3(Y)                    P,3    A,3,Y
                                    ^ chosen
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Y is chosen.
&lt;code&gt;A,1,X&lt;/code&gt; is rejected, because 3 &amp;gt; 1.&lt;/p&gt;

&lt;h3 id=&#34;e-g-4:8aa297440e030e6ae04600c7109020a5&#34;&gt;E.g. 4&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;S1(X)    P,1    A,1,X                                  A,3,Y(rej)
S2       P,1             P,3             A,1,X(rej)    A,3,Y
S3(Y)                    P,3    A,3,Y    A,1,X(rej)    
                                                           ^ chosen
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Y is chosen.
Later, Learner will find out Y is the chosen value, and then send decided(Y) to all servers.&lt;/p&gt;

&lt;h2 id=&#34;links:8aa297440e030e6ae04600c7109020a5&#34;&gt;Links&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;[1]. &lt;a href=&#34;http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf&#34;&gt;Lamport, Leslie. &amp;ldquo;Paxos made simple.&amp;rdquo; ACM Sigact News 32, no. 4 (2001): 18-25.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2]. &lt;a href=&#34;http://nil.csail.mit.edu/6.824/2015/notes/paxos-code.html&#34;&gt;Handout, LEC5, 6.824&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[3]. &lt;a href=&#34;https://www.youtube.com/watch?v=JEpsBg0AO6o&#34;&gt;Paxos lecture (Raft user study)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;end.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>make slice map channel</title>
      <link>http://neilsh.me/2015/11/09/make-slice-map-channel/</link>
      <pubDate>Mon, 09 Nov 2015 15:16:55 +0800</pubDate>
      
      <guid>http://neilsh.me/2015/11/09/make-slice-map-channel/</guid>
      <description>

&lt;h2 id=&#34;where-is-the-make-implemention:f54eeb4205b24658133f3791bb00140a&#34;&gt;Where is the make implemention?&lt;/h2&gt;

&lt;p&gt;package &lt;strong&gt;runtime&lt;/strong&gt;
By the way, &lt;em&gt;new&lt;/em&gt;, &lt;em&gt;map&lt;/em&gt;, &lt;em&gt;slice&lt;/em&gt;, &lt;em&gt;channel&lt;/em&gt;, &lt;em&gt;goroutine&lt;/em&gt; and &lt;em&gt;garbage collector&lt;/em&gt;[&lt;a href=&#34;https://docs.google.com/document/d/1P3BLR31VA8cvLJLfMibSuTdwTuF7WWLux71CYD0eeD8&#34;&gt;1&lt;/a&gt;] are also implemented in this package.&lt;/p&gt;

&lt;h2 id=&#34;slices:f54eeb4205b24658133f3791bb00140a&#34;&gt;Slices&lt;/h2&gt;

&lt;p&gt;Source file: go/src/runtime/slice.go&lt;/p&gt;

&lt;h3 id=&#34;data-structure:f54eeb4205b24658133f3791bb00140a&#34;&gt;Data structure&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Underlying data structure of &lt;strong&gt;slice&lt;/strong&gt; is trival. Go is statically typed, and why this litte struct can be the template of any type of slices? Well, look at the comments of &lt;code&gt;unsafe.Pointer&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Pointer represents a pointer to an arbitrary type.  There are four special operations
// available for type Pointer that are not available for other types.
//  1) A pointer value of any type can be converted to a Pointer.
//  2) A Pointer can be converted to a pointer value of any type.  &amp;lt;-- here!
//  3) A uintptr can be converted to a Pointer.
//  4) A Pointer can be converted to a uintptr.
// Pointer therefore allows a program to defeat the type system and read and write
// arbitrary memory. It should be used with extreme care.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, &lt;strong&gt;Pointer&lt;/strong&gt; in Go is &lt;strong&gt;*void&lt;/strong&gt; in C. &lt;em&gt;Pointer&lt;/em&gt; anesthetizes the type system and read and write arbitrary memory in Go. &lt;em&gt;*void&lt;/em&gt; can be converted to any type without warning in C.&lt;/p&gt;

&lt;h3 id=&#34;make-slices:f54eeb4205b24658133f3791bb00140a&#34;&gt;Make slices&lt;/h3&gt;

&lt;p&gt;Make slices is trival.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// TODO: take uintptrs instead of int64s?
func makeslice(t *slicetype, len64, cap64 int64) slice {
    // NOTE: The len &amp;gt; MaxMem/elemsize check here is not strictly necessary,
    // but it produces a &#39;len out of range&#39; error instead of a &#39;cap out of range&#39; error
    // when someone does make([]T, bignumber). &#39;cap out of range&#39; is true too,
    // but since the cap is only being supplied implicitly, saying len is clearer.
    // See issue 4085.
    len := int(len64)
    if len64 &amp;lt; 0 || int64(len) != len64 || t.elem.size &amp;gt; 0 &amp;amp;&amp;amp; uintptr(len) &amp;gt; _MaxMem/uintptr(t.elem.size) {
        panic(errorString(&amp;quot;makeslice: len out of range&amp;quot;))
    }
    cap := int(cap64)
    if cap &amp;lt; len || int64(cap) != cap64 || t.elem.size &amp;gt; 0 &amp;amp;&amp;amp; uintptr(cap) &amp;gt; _MaxMem/uintptr(t.elem.size) {
        panic(errorString(&amp;quot;makeslice: cap out of range&amp;quot;))
    }
    p := newarray(t.elem, uintptr(cap))
    return slice{p, len, cap}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, a slice is always 24 bytes(amd64, ubuntu 14.04 LTS), no matter how many elements it has or how much capacity it is. The actual data that a slice represents locate in other place, not in the slice itself. More details about slice can be found in [&lt;a href=&#34;https://gist.github.com/Overvenus/f6cf225ec33cc98d6b8c&#34;&gt;3&lt;/a&gt;] and [&lt;a href=&#34;https://blog.golang.org/go-slices-usage-and-internals&#34;&gt;4&lt;/a&gt;].&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;newarray&lt;/strong&gt; eventually calls &lt;strong&gt;mallocgc&lt;/strong&gt;, which will allocate memory in heap(for big array) or per-thread cache (for small array) [&lt;a href=&#34;http://goog-perftools.sourceforge.net/doc/tcmalloc.html&#34;&gt;2&lt;/a&gt;].&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// implementation of make builtin for slices
func newarray(typ *_type, n uintptr) unsafe.Pointer {
    flags := uint32(0)
    if typ.kind&amp;amp;kindNoPointers != 0 {
        flags |= flagNoScan
    }
    if int(n) &amp;lt; 0 || (typ.size &amp;gt; 0 &amp;amp;&amp;amp; n &amp;gt; _MaxMem/uintptr(typ.size)) {
        panic(&amp;quot;runtime: allocation size out of range&amp;quot;)
    }
    return mallocgc(uintptr(typ.size)*n, typ, flags)
    /*                               ^^  multiply size by n  */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;maps:f54eeb4205b24658133f3791bb00140a&#34;&gt;Maps&lt;/h2&gt;

&lt;p&gt;Source file: go/src/runtime/hashmap.go&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;// A map is just a hash table.  The data is arranged
// into an array of buckets.  Each bucket contains up to
// 8 key/value pairs.  The low-order bits of the hash are
// used to select a bucket.  Each bucket contains a few
// high-order bits of each hash to distinguish the entries
// within a single bucket.
//
// If more than 8 keys hash to a bucket, we chain on
// extra buckets.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;data-structure-1:f54eeb4205b24658133f3791bb00140a&#34;&gt;Data structure&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// A header for a Go map.
type hmap struct {
    // Note: the format of the Hmap is encoded in ../../cmd/internal/gc/reflect.go and
    // ../reflect/type.go.  Don&#39;t change this structure without also changing that code!
    count int // # live cells == size of map.  Must be first (used by len() builtin)
    flags uint8
    B     uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)
    hash0 uint32 // hash seed

    buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.
    oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing
    nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)

    // If both key and value do not contain pointers and are inline, then we mark bucket
    // type as containing no pointers. This avoids scanning such maps.
    // However, bmap.overflow is a pointer. In order to keep overflow buckets
    // alive, we store pointers to all overflow buckets in hmap.overflow.
    // Overflow is used only if key and value do not contain pointers.
    // overflow[0] contains overflow buckets for hmap.buckets.
    // overflow[1] contains overflow buckets for hmap.oldbuckets.
    // The first indirection allows us to reduce static size of hmap.
    // The second indirection allows to store a pointer to the slice in hiter.
    overflow *[2]*[]*bmap
}

// A bucket for a Go map.
type bmap struct {
    tophash [bucketCnt]uint8
    // Followed by bucketCnt keys and then bucketCnt values.
    // NOTE: packing all the keys together and then all the values together makes the
    // code a bit more complicated than alternating key/value/key/value/... but it allows
    // us to eliminate padding which would be needed for, e.g., map[int64]int8.
    // Followed by an overflow pointer.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;make-maps:f54eeb4205b24658133f3791bb00140a&#34;&gt;Make maps&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// makemap implements a Go map creation make(map[k]v, hint)
// If the compiler has determined that the map or the first bucket
// can be created on the stack, h and/or bucket may be non-nil.
// If h != nil, the map can be created directly in h.
// If bucket != nil, bucket can be used as the first bucket.
func makemap(t *maptype, hint int64, h *hmap, bucket unsafe.Pointer) *hmap {
    if !ismapkey(t.key) {                             /* pointer --&amp;gt; ^^^^^ */
        throw(&amp;quot;runtime.makemap: unsupported map key type&amp;quot;)
    }

    /* I delete some checks */

    // make sure zeroptr is large enough
    mapzero(t.elem)

    // find size parameter which will hold the requested # of elements
    B := uint8(0)
    for ; hint &amp;gt; bucketCnt &amp;amp;&amp;amp; float32(hint) &amp;gt; loadFactor*float32(uintptr(1)&amp;lt;&amp;lt;B); B++ {
    }

    // allocate initial hash table
    // if B == 0, the buckets field is allocated lazily later (in mapassign)
    // If hint is large zeroing this memory could take a while.
    buckets := bucket
    if B != 0 {
        buckets = newarray(t.bucket, uintptr(1)&amp;lt;&amp;lt;B)
    }

    // initialize Hmap
    if h == nil {
        h = (*hmap)(newobject(t.hmap))  /*  */
    }
    h.count = 0
    h.B = B
    h.flags = 0
    h.hash0 = fastrand1()
    h.buckets = buckets
    h.oldbuckets = nil
    h.nevacuate = 0

    return h
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A map is always 8 bytes(amd64, ubuntu 14.04 LTS), because &lt;code&gt;makemap&lt;/code&gt; returns a poniter, ponites to hmap, the underlying data sturcture is allocated in heap.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// implementation of new builtin
func newobject(typ *_type) unsafe.Pointer {
    flags := uint32(0)
    if typ.kind&amp;amp;kindNoPointers != 0 {
        flags |= flagNoScan
    }
    return mallocgc(uintptr(typ.size), typ, flags)
    /* compares with newarray, no multiplication */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is worth nothing that &lt;code&gt;v, ok := map[k]&lt;/code&gt; and &lt;code&gt;v := map[k]&lt;/code&gt; are also implemented in this file.&lt;/p&gt;

&lt;h2 id=&#34;channel:f54eeb4205b24658133f3791bb00140a&#34;&gt;Channel&lt;/h2&gt;

&lt;p&gt;source file: go/src/runtime/channel.go&lt;/p&gt;

&lt;h3 id=&#34;data-structure-2:f54eeb4205b24658133f3791bb00140a&#34;&gt;Data structure&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;type hchan struct {
    qcount   uint           // total data in the queue
    dataqsiz uint           // size of the circular queue
    buf      unsafe.Pointer // points to an array of dataqsiz elements
    elemsize uint16
    closed   uint32
    elemtype *_type // element type
    sendx    uint   // send index
    recvx    uint   // receive index
    recvq    waitq  // list of recv waiters
    sendq    waitq  // list of send waiters
    lock     mutex
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;make-chan:f54eeb4205b24658133f3791bb00140a&#34;&gt;Make chan&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;func makechan(t *chantype, size int64) *hchan {
    elem := t.elem

    /* I delete some checks */

    var c *hchan
    if elem.kind&amp;amp;kindNoPointers != 0 || size == 0 {
        // Allocate memory in one call.
        // Hchan does not contain pointers interesting for GC in this case:
        // buf points into the same allocation, elemtype is persistent.
        // SudoG&#39;s are referenced from their owning thread so they can&#39;t be collected.
        // TODO(dvyukov,rlh): Rethink when collector can move allocated objects.
        c = (*hchan)(mallocgc(hchanSize+uintptr(size)*uintptr(elem.size), nil, flagNoScan))
        if size &amp;gt; 0 &amp;amp;&amp;amp; elem.size != 0 {
            c.buf = add(unsafe.Pointer(c), hchanSize)
        } else {
            // race detector uses this location for synchronization
            // Also prevents us from pointing beyond the allocation (see issue 9401).
            c.buf = unsafe.Pointer(c)
        }
    } else {
        c = new(hchan)
        c.buf = newarray(elem, uintptr(size))
    }
    c.elemsize = uint16(elem.size)
    c.elemtype = elem
    c.dataqsiz = uint(size)

    if debugChan {
        print(&amp;quot;makechan: chan=&amp;quot;, c, &amp;quot;; elemsize=&amp;quot;, elem.size, &amp;quot;; elemalg=&amp;quot;, elem.alg, &amp;quot;; dataqsiz=&amp;quot;, size, &amp;quot;\n&amp;quot;)
    }
    return c
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A channel variable at runtime(not package) is very much like a map variable, they are both pointers, pointes to heap.&lt;/p&gt;

&lt;h2 id=&#34;make-gist:f54eeb4205b24658133f3791bb00140a&#34;&gt;Make gist&lt;/h2&gt;

&lt;p&gt;I wrote a gist to uncover slice, map and channel at runtime(not package)&lt;a href=&#34;http://goog-perftools.sourceforge.net/doc/tcmalloc.html&#34;&gt;2&lt;/a&gt;.&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/Overvenus/f6cf225ec33cc98d6b8c.js&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;outputs-in-my-laptop:f54eeb4205b24658133f3791bb00140a&#34;&gt;Outputs in my laptop&lt;/h3&gt;

&lt;p&gt;Env: Ubuntu 14.04 LTS, amd64&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go run make.go
GOOS linux
GOARCH amd64
--- array &amp;amp; slice ---
si: type: [100]int
si: sizeof: 800
si: address 1st ele.: 0xc820062380
---
asi:    type: *[100]int
asi:    sizeof: 8
asi:    address: 0xc820062380
asi:    address 1st ele.: 0xc820062380
---
si[:20]:    type: []int
si[:20]:    sizeof: 24
si[:20]:    address 1st ele.: 0xc820062380
---
si[:80]:    type: []int
si[:80]:    sizeof: 24
si[:80]:    address 1st ele.: 0xc820062380
---
assi:   type: *[]int
assi:   sizeof: 8
assi:   address: 0xc8200105e0
--- map ---
m:  type: map[int]int
m:  sizeof: 8
---
am: type: *map[int]int
am: sizeof: 8
--- channel ---
ci: type: chan int
ci: sizeof: 8
---
aci:    type: *chan int
aci:    sizeof: 8
---
ci: type: chan int
ci: sizeof: 8
---
abci:   type: *chan int
abci:   sizeof: 8
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;links:f54eeb4205b24658133f3791bb00140a&#34;&gt;Links&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;[1], &lt;a href=&#34;https://docs.google.com/document/d/1P3BLR31VA8cvLJLfMibSuTdwTuF7WWLux71CYD0eeD8&#34;&gt;Go 1.3+ Compiler Overhaul&lt;/a&gt;
[2], &lt;a href=&#34;http://goog-perftools.sourceforge.net/doc/tcmalloc.html&#34;&gt;TCMalloc : Thread-Caching Malloc&lt;/a&gt;
[3], &lt;a href=&#34;https://gist.github.com/Overvenus/f6cf225ec33cc98d6b8c&#34;&gt;slice, map and channel at runtime&lt;/a&gt;
[4], &lt;a href=&#34;https://blog.golang.org/go-slices-usage-and-internals&#34;&gt;Go Slices: usage and internals&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;End.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Protocol and FSM</title>
      <link>http://neilsh.me/2015/10/23/protocol-and-fsm/</link>
      <pubDate>Fri, 23 Oct 2015 21:17:01 +0800</pubDate>
      
      <guid>http://neilsh.me/2015/10/23/protocol-and-fsm/</guid>
      <description>

&lt;h2 id=&#34;protocol:1dc0ee46b9edee2e1b8795e1ccd0910d&#34;&gt;Protocol&lt;/h2&gt;

&lt;p&gt;本文中 Protocol 特指通讯协议。
首先简单的介绍一下什么是 Protocol，来看看 WIKI 上是怎么定义它的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Communications protocol, a defined set of rules and regulations that determine how data is transmitted in telecommunications and computer networking  &amp;ndash;&lt;a href=&#34;https://en.wikipedia.org/wiki/Protocol&#34;&gt;WIKI#Protocol&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单的来说，协议是规范数据传输的一套规则。&lt;/p&gt;

&lt;h2 id=&#34;finite-state-machines-fsm:1dc0ee46b9edee2e1b8795e1ccd0910d&#34;&gt;Finite State Machines (FSM)&lt;/h2&gt;

&lt;p&gt;下面是摘自 WIKI 的对有限状态机的说明：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;It is conceived as an abstract machine that can be in one of a finite number of states. The machine is in only one state at a time; the state it is in at any given time is called the current state. It can change from one state to another when initiated by a triggering event or condition; this is called a transition. A particular FSM is defined by a list of its states, and the triggering condition for each transition.    &amp;ndash;&lt;a href=&#34;https://en.wikipedia.org/wiki/Finite-state_machine&#34;&gt;WIKI#FSM&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;有限状态机是一种抽象的机器，拥有有限个状态。它在每个确定的时刻有且只有一个状态（当前状态），它的状态会由于输入条件而发生变化。一个状态转移表可以定义一个有限状态机。
有点绕，不过按我的理解，有限状态机有两个关键点，状态和输入条件。这两者之间有一套规则束缚着，规则就这个 FSM 的行为。&lt;/p&gt;

&lt;h2 id=&#34;protocol-and-fsm:1dc0ee46b9edee2e1b8795e1ccd0910d&#34;&gt;Protocol and FSM&lt;/h2&gt;

&lt;p&gt;把 Protocol 和 FSM 写在一起自然是因为它们有着紧密的联系。不准确的来说， Protocol 就是 FSM 的行为，遵循 Protocol 的实体（们）构成了这个 FSM 的抽象机器。&lt;/p&gt;

&lt;h2 id=&#34;implement-a-protocol:1dc0ee46b9edee2e1b8795e1ccd0910d&#34;&gt;Implement a Protocol&lt;/h2&gt;

&lt;p&gt;实现协议不简单，特别是复杂的，持续状态的协议，TCP 算其中一个😂。
列一下实现协议的困难点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;状态可能有多种。&lt;/li&gt;
&lt;li&gt;条件可能有多种。&lt;/li&gt;
&lt;li&gt;1, 2组合产生的情况更多！&lt;/li&gt;
&lt;li&gt;因逻辑不清而产生的 BUG 难以排查。&lt;/li&gt;
&lt;li&gt;复杂协议容易产生高耦合的代码。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;说了困难点，当然要题解决思路：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;编写代码前画出状态转移图，理清思路。&lt;/li&gt;
&lt;li&gt;编写代码前定好各个函数的作用，及调用范围。&lt;/li&gt;
&lt;li&gt;编写代码时避免过早的优化， premature optimization is the root of all evil， Knuth&lt;/li&gt;
&lt;li&gt;有 Test case 那自然是极好的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这四点，箭箭射中我膝盖。唉，人啊，为什么痛过之后才知道悔改！（严肃脸）&lt;/p&gt;

&lt;h2 id=&#34;viewservice:1dc0ee46b9edee2e1b8795e1ccd0910d&#34;&gt;Viewservice&lt;/h2&gt;

&lt;p&gt;6.824 的 lab2 Part A 让我们实现一个具体的协议。计算机有随时宕机的可能，一旦发生它提供的服务就不可得了。该协议引入主机（Primary）和从机（Backup）机制并及时检查两者的存活状态，使系统服务具有高可用性，下面称这个协议为 &lt;strong&gt;Viewservice&lt;/strong&gt;。
Viewservice 在某些条件下会产生一个 &lt;strong&gt;View&lt;/strong&gt;。View 是一个数据结构，包含主机和从机的地址。
下面说一下这个协议要关键的几个点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;持续状态协议，当前状态会影响到下一状态。&lt;/li&gt;
&lt;li&gt;每次更新 View， Primary 不能为空。&lt;/li&gt;
&lt;li&gt;下一个 View 中的 Primary 必须为当前 View 的 Primary 或 Backup。&lt;/li&gt;
&lt;li&gt;每个活动的服务器都保存在 viewserver 中，状态是 Primary, Backup, Idle 其中的一种。&lt;/li&gt;
&lt;li&gt;当前 View 中的 Primary 和 Backup 同时出错时，服务结束。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面几点并没有完整地描述 Viewservice，但已足够用来阐述 Protocol 和 FSM 之前的关系，想看完整的协议请访问&lt;a href=&#34;http://nil.csail.mit.edu/6.824/2015/labs/lab-2.html&#34;&gt;lab2#Part A&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;viewservice-fsm:1dc0ee46b9edee2e1b8795e1ccd0910d&#34;&gt;Viewservice FSM&lt;/h2&gt;

&lt;p&gt;不难发现 View 就是状态，条件就是 Primary，Backup，Idle三者的存活状态。
注意，为了便于理解，这里的 FSM 只是完整的 Viewservice 中的&lt;strong&gt;关键部分（错误处理）&lt;/strong&gt;，我去掉了一些无关痛痒的内容，并且我对 Idle 多了一个限制：每个时刻要没有 Idle，要么只有一个，不会有多个存在。但就算这个限制不存在也不会影响最后的正确性。这样做的好处是 Idle 只有两种状态，简化了条件的同时还便于表示（0 or 1） ;-)&lt;/p&gt;

&lt;p&gt;由此设三位二进制数：XXX， 分别代表 Primary，Backup和Idle。1为存活，0为出错。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Primary&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Backup&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Idle&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;XXX&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Alive&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;111&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Dead&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;可能输出的状态有四种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;100，只有 Primary 存活。&lt;/li&gt;
&lt;li&gt;110，Primary 和 Backup 存活，没有 Idle。&lt;/li&gt;
&lt;li&gt;111，Primary，Backup 和 Idle 都存活。&lt;/li&gt;
&lt;li&gt;00X，Primary 和 Backup， 服务结束。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意： X 代表 0 和 1，00X 就是 000 和 001 的合集&lt;/p&gt;

&lt;p&gt;所有可能的条件：&lt;/p&gt;

&lt;p&gt;1.100
 2.101
 3.110
 4.111
 5.010
 6.011
 7.00X&lt;/p&gt;

&lt;p&gt;两者产生的状态转移表： 竖为当前状态，横为条件，&lt;code&gt;\&lt;/code&gt; 为不会出现的情况&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;100&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;101&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;110&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;111&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;010&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;011&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;00X&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;110&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;100&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;00X&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;110&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;110&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;110&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;100&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;111&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;100&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;110&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;00X&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;111&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;110&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;110&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;100&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;111&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;100&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;110&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;00X&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;00X&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;00X&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;00X&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;00X&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;00X&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;00X&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;00X&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;00X&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;根据上面的表可以画出状态转移图，更直观地说明这个 FSM&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/7f793092gw1exdcpwse63j21kw15madn.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;清楚了这个 FSM，各种情况了然于心，设计数据结构，编写代码，实现协议 so easy。&lt;/p&gt;

&lt;h2 id=&#34;后话:1dc0ee46b9edee2e1b8795e1ccd0910d&#34;&gt;后话&lt;/h2&gt;

&lt;p&gt;Part A部分我花了不少时间，主要还是当初没有理清协议，有多个 Test 通不过，代码结构推到了一遍又一遍。在机缘巧合下（debug下）发现协议和数电中的状态转移图有紧密的联系。然后尝试用状态转移图来表示协议，没想到还真可以。根据状态转移图改善了一下代码，通过各种 Test 快得飞起！这么好的方法不可能没有人比我先想到，查了 google 才知道有个概念叫*有限状态机*，有门课叫 *Protocol Engineering*，我的视野还太小。最后发一张 TCP 的状态转移图，感受下 TCP 的复杂性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/f/f6/Tcp_state_diagram_fixed_new.svg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;ref:1dc0ee46b9edee2e1b8795e1ccd0910d&#34;&gt;Ref.&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://nil.csail.mit.edu/6.824/2015/labs/lab-2.html&#34;&gt;lab2#Part A&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Protocol&#34;&gt;WIKI#Protocol&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Finite-state_machine&#34;&gt;WIKI#FSM&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Transmission_Control_Protocol&#34;&gt;WIKI#TCP&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://pet.ece.iisc.ernet.in/course/E2223/ch.pdf&#34;&gt;Specification of Protocol Using FSM&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://cs.uccs.edu/~cs522/pe/pe.htm&#34;&gt;Protocol Specification using Sequence Chart or Message Flow DiagramApply Formal Method To Protocol Specification&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;End.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go Note</title>
      <link>http://neilsh.me/2015/10/08/golang-note/</link>
      <pubDate>Thu, 08 Oct 2015 22:03:01 +0800</pubDate>
      
      <guid>http://neilsh.me/2015/10/08/golang-note/</guid>
      <description>

&lt;!--
TODO:
   - ...
--&gt;

&lt;h2 id=&#34;new-make-and-local-variable:29d085475296ad0ae0e08e9c74a587d0&#34;&gt;&lt;code&gt;new&lt;/code&gt;, &lt;code&gt;make&lt;/code&gt; and Local variable&lt;/h2&gt;

&lt;p&gt;In short: new allocates memory; make initializes the slice, map, and channel types; local variable may be not &lt;em&gt;local&lt;/em&gt; at all.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;new&lt;/code&gt;: new(T) allocates zeroed storage for a new item of type T and returns its address, a value of type *T. In Go terminology, it returns a pointer to a newly allocated zero value of type T.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;make&lt;/code&gt;: creates slices, maps, and channels only, and it returns an &lt;em&gt;initialized (not zeroed)&lt;/em&gt; value of type T (not *T).&lt;/p&gt;

&lt;p&gt;Local variable: unlike in C, it&amp;rsquo;s perfectly OK to return the address of a local variable; the storage associated with the variable survives after the function returns. In fact, taking the address of a composite literal allocates a fresh instance each time it is evaluated, so we can combine these last two lines. (e.g., &lt;code&gt;return &amp;amp;File{fd: fd, name: name}&lt;/code&gt;)
 &amp;ndash; &lt;a href=&#34;https://golang.org/doc/effective_go.html#allocation_new&#34;&gt;Effective GO#allocation_new&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;stack-or-heap:29d085475296ad0ae0e08e9c74a587d0&#34;&gt;Stack or Heap?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/doc/faq#stack_or_heap&#34;&gt;Golang FAQ#stackheap&lt;/a&gt;
&lt;strong&gt;How do I know whether a variable is allocated on the heap or the stack?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;From a correctness standpoint, you don&amp;rsquo;t need to know. Each variable in Go exists as long as there are &lt;em&gt;references&lt;/em&gt; to it. The storage location chosen by the implementation is irrelevant to the semantics of the language.&lt;/p&gt;

&lt;p&gt;The storage location does have an effect on writing efficient programs. When possible, the Go compilers will allocate variables that are local to a function in that function&amp;rsquo;s stack frame. However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors. Also, if a local variable is very large, it might make more sense to store it on the heap rather than the stack.&lt;/p&gt;

&lt;p&gt;In the current compilers, if a variable has its address taken, that variable is a candidate for allocation on the heap. However, a basic escape analysis recognizes some cases when such variables will not live past the return from the function and can reside on the stack.&lt;/p&gt;

&lt;p&gt;An excellent talk about stack and heap of Go. &lt;a href=&#34;http://dave.cheney.net/2014/06/07/five-things-that-make-go-fast&#34;&gt;Five things that make Go fast&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;happen-before-and-channel:29d085475296ad0ae0e08e9c74a587d0&#34;&gt;Happen before and Channel&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/ref/mem#tmp_7&#34;&gt;Golang Memory Model#channel&lt;/a&gt;
&amp;gt; A send on a channel happens before the corresponding receive from that channel completes.&lt;/p&gt;

&lt;p&gt;An interesting case where &lt;em&gt;Happen Before&lt;/em&gt; will take place.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var c = make(chan int)
var a string

func f() {
    a = &amp;quot;hello, world&amp;quot;
    &amp;lt;-c
}
func main() {
    go f()
    c &amp;lt;- 0
    print(a)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This snippet guarantes to print &amp;ldquo;hello, world&amp;rdquo;. The write to a happens before the receive on c, which happens before the corresponding send on c completes, which happens before the print.
If the channel were buffered (e.g., &lt;code&gt;c = make(chan int, 1)&lt;/code&gt;) then the program would not be guaranteed to print &amp;ldquo;hello, world&amp;rdquo;. (It might print the empty string, crash, or do something else.)&lt;/p&gt;

&lt;h2 id=&#34;concurrency:29d085475296ad0ae0e08e9c74a587d0&#34;&gt;Concurrency&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://talks.golang.org/2012/concurrency.slide&#34;&gt;Go Concurrency Patterns&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;main-exits:29d085475296ad0ae0e08e9c74a587d0&#34;&gt;&lt;code&gt;main&lt;/code&gt; exits&lt;/h3&gt;

&lt;p&gt;What happens to goroutines that running background when main function returns?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;When the main returns, the programm goes away.
       &amp;ndash; &lt;a href=&#34;https://youtu.be/f6kdp27TYZs?t=7m46s&#34;&gt;Rob Pike#main_exit&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It confused me for a long time, now I get a concrete answer.&lt;/p&gt;

&lt;h3 id=&#34;generator-in-go:29d085475296ad0ae0e08e9c74a587d0&#34;&gt;Generator in Go&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Generator: function that returns a channel.
Channels are first-class values, just like strings or integers.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;
import &amp;quot;time&amp;quot;
import &amp;quot;math/rand&amp;quot;

func main() {
    // Python-like usage
    for s := range boring(&amp;quot;generator&amp;quot;) {
        fmt.Println(s)
    }

    fmt.Println(&amp;quot;func main exits&amp;quot;)
}

// ### Generator ###
func boring(msg string) &amp;lt;-chan string { // Returns receive-only channel of strings.
    c := make(chan string)
    go func() { // We launch the goroutine from inside the function.
        for i := 0; i &amp;lt; 10; i++ {
            c &amp;lt;- fmt.Sprintf(&amp;quot;%s %d&amp;quot;, msg, i)
            time.Sleep(time.Duration(rand.Intn(1e3)) * time.Millisecond)
        }
        close(c) // close channel c, otherwise for-range will be blocked.
    }()
    return c // Return the channel to the caller.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unlike &lt;strong&gt;Generator&lt;/strong&gt; in Python, the concept in Go is simple: &lt;em&gt;Generator: function that returns a channel&lt;/em&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Python Generator: generates data in time.&lt;/li&gt;
&lt;li&gt;Go Generator: return a channel, reveives data in time.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;tricky-keyword-select:29d085475296ad0ae0e08e9c74a587d0&#34;&gt;Tricky Keyword, &lt;code&gt;select&lt;/code&gt;&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Select&lt;/p&gt;

&lt;p&gt;The select statement provides another way to handle multiple channels.
It&amp;rsquo;s like a switch, but each case is a communication:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;All channels are evaluated.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Selection blocks until one communication can proceed, which then does.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If multiple can proceed, select chooses pseudo-randomly.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A default clause, if present, executes immediately if no channel is ready.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;select {
    case v1 := &amp;lt;-c1:
        fmt.Printf(&amp;quot;received %v from c1\n&amp;quot;, v1)
    case v2 := &amp;lt;-c2:
        fmt.Printf(&amp;quot;received %v from c2\n&amp;quot;, v1)
    case c3 &amp;lt;- 23:
        fmt.Printf(&amp;quot;sent %v to c3\n&amp;quot;, 23)
    default:
        fmt.Printf(&amp;quot;no one was ready to communicate\n&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Select with &lt;strong&gt;default&lt;/strong&gt; is a non-blocking statement, even if no other case can be processed. Without &lt;strong&gt;default&lt;/strong&gt;, select block forever if no other case can be processed.&lt;/p&gt;

&lt;p&gt;END.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ReadingFragment Structured Computer Organization</title>
      <link>http://neilsh.me/2015/09/21/fragment_structured_computer_organization/</link>
      <pubDate>Mon, 21 Sep 2015 19:44:01 +0800</pubDate>
      
      <guid>http://neilsh.me/2015/09/21/fragment_structured_computer_organization/</guid>
      <description>

&lt;h1 id=&#34;parallelism-in-computer-organization:6d7bed0c23ab487a1f7c5d950efc77a7&#34;&gt;Parallelism in Computer Organization&lt;/h1&gt;

&lt;p&gt;Why we need parallel computing? Because we are close to the limit of physics &amp;ndash; the speed of light and memory becomes the bottleneck of computer.&lt;/p&gt;

&lt;h2 id=&#34;parallelism-in-cpu:6d7bed0c23ab487a1f7c5d950efc77a7&#34;&gt;Parallelism in CPU&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Pipeline

&lt;ul&gt;
&lt;li&gt;Sinlge pipeline&lt;/li&gt;
&lt;li&gt;Mutli-pipeline&lt;/li&gt;
&lt;li&gt;Superscalar pipeline&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Array Computers, single control unit and a array of processor.&lt;/li&gt;
&lt;li&gt;Multiprocessors, multiple CPUs shared with one common  main memory, and communicate through BUS.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;parallelism-in-memory:6d7bed0c23ab487a1f7c5d950efc77a7&#34;&gt;Parallelism in Memory&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Modern CPUs has it&amp;rsquo;s own private memory, cache.&lt;/li&gt;
&lt;li&gt;Redundant Array of Inexpensive Disk(RAID), there are 5 level of RAID. I will be surprised if one system supports all 5 level RAID, especially level 2 and 3 ;-)

&lt;ul&gt;
&lt;li&gt;Level 0, strips data(typically, a sector) over disks in round robin fashion. No backups.&lt;/li&gt;
&lt;li&gt;Level 1, make an additional redundant backup of level 0.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ijvm:6d7bed0c23ab487a1f7c5d950efc77a7&#34;&gt;IJVM&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;IJVM&lt;/strong&gt; is short for &lt;em&gt;Integer instructions only Java Virtual Machine&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;ijvm-memory-model:6d7bed0c23ab487a1f7c5d950efc77a7&#34;&gt;IJVM Memory Model&lt;/h2&gt;

&lt;p&gt;It looks like IJVM has a set of different stack operations compares with other machines. IJVM instructions can access memory only by indexing from some special registers. CPP, LV and SP point to word(4 bytes).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The constant pool, addressing by CPP, it is loaded when the program is brought into memory and read-only afterward.&lt;/li&gt;
&lt;li&gt;The Local variable frame, addressing by LV.&lt;/li&gt;
&lt;li&gt;The operand stack, addressing by SP. Push and pop actions take place in this stack.&lt;/li&gt;
&lt;li&gt;The method area, consider as the &amp;ldquo;TEXT&amp;rdquo; area in UNIX&amp;rsquo;s memory, addressing by PC. The first 2 byte indicating the number of parameters for the method, the second 2 bytes indicating the size of the local variables, opcode begins at the 5th byte.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ijvm-method-invocation:6d7bed0c23ab487a1f7c5d950efc77a7&#34;&gt;IJVM method invocation&lt;/h2&gt;

&lt;p&gt;Instead of using &lt;code&gt;CALL&lt;/code&gt; instraction, JVM use &lt;code&gt;INVOKEVIRTUAL&lt;/code&gt;. Below is a brief explanation of method invocation(highly recommad reading &lt;a href=&#34;http://users.cis.fiu.edu/~prabakar/cda4101/Common/notes/lecture20.html&#34;&gt;CDA-4101 Lecture 20 Notes&lt;/a&gt;)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Push &lt;code&gt;PC&lt;/code&gt;, &lt;code&gt;LV&lt;/code&gt;, &lt;code&gt;OBJREF&lt;/code&gt;(reference of the method&amp;rsquo;s object) and parameters into Local variable frame.&lt;/li&gt;
&lt;li&gt;Build a new Local variable frame, the size of the new frame are determined by the second 2 bytes reading from The method area, and stores the caller&amp;rsquo;s PC ans LV in the top of the new frame. Replace &lt;code&gt;OBJREF&lt;/code&gt; with &lt;code&gt;Link ptr&lt;/code&gt; which points to the caller&amp;rsquo;s PC. Now &lt;code&gt;LV&lt;/code&gt; points to &lt;code&gt;Link ptr&lt;/code&gt; and &lt;code&gt;SP&lt;/code&gt; points to caller&amp;rsquo;s LV.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PC&lt;/code&gt; points to 5th byte in the method area.&lt;/li&gt;
&lt;li&gt;Mark the new local variables frame as the current frame by seting &lt;code&gt;LV&lt;/code&gt; with the address of &lt;code&gt;OBJREF&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;After the method is done, the return value will be stored in &lt;code&gt;OBJREF&lt;/code&gt; (&lt;code&gt;Link ptr&lt;/code&gt;).&lt;/p&gt;

&lt;h2 id=&#34;some-qs-about-jvm:6d7bed0c23ab487a1f7c5d950efc77a7&#34;&gt;Some Qs about JVM&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Give the Java statement that produced the following IJVM code:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;       ILOAD j
       ILOAD n
       ISUB
       BIPUSH 7
       ISUB
       DUP
       IADD
       ISTORE i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A: &lt;code&gt;i = (j - n - 7) x 2;&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The JVM &lt;code&gt;INVOKEVIRTUAL&lt;/code&gt; instruction needs to know how many parameters it has. Why?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A: Old &lt;code&gt;PC&lt;/code&gt; and &lt;code&gt;LV&lt;/code&gt; will be stored on address of the top of local variables which will be computed by adding the size of local variables and &lt;strong&gt;parameters&lt;/strong&gt;.&lt;/p&gt;

&lt;h1 id=&#34;intel-core-i7:6d7bed0c23ab487a1f7c5d950efc77a7&#34;&gt;Intel Core i7&lt;/h1&gt;

&lt;p&gt;Core i7 is a CPU with CISC outside and RISC inside. In side the chip, there is a decoder which build a bridge between CISC instructions and RISC data path.&lt;/p&gt;

&lt;h1 id=&#34;ref:6d7bed0c23ab487a1f7c5d950efc77a7&#34;&gt;Ref.&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;Structured Computer Organization(6th Edition) by Andrew S. Tanenbaum
&lt;a href=&#34;http://users.cis.fiu.edu/~prabakar/cda4101/Common/notes/lecture20.html&#34;&gt;CDA-4101 Lecture 20 Notes&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;个人笔记，难免有误，如有发现，还望指出。
END.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>jupyter-core 4.0.6 的发布</title>
      <link>http://neilsh.me/2015/09/18/jupyter-core-406/</link>
      <pubDate>Fri, 18 Sep 2015 20:39:01 +0800</pubDate>
      
      <guid>http://neilsh.me/2015/09/18/jupyter-core-406/</guid>
      <description>

&lt;h1 id=&#34;jupyter-与-ipython:9efbcfe4e76745ed4d55523f6b11c597&#34;&gt;Jupyter 与 IPython&lt;/h1&gt;

&lt;p&gt;Jupyter 是由 IPython 演化而来的，两者配合使用可提供交互式的编程体验，实现视觉化编程，写了什么，马上就能看见效果。Jupyter 类似于客户端，IPython 作为 Jupyter 的内核。之前 IPython 的杀手锏 notebook 现在转移到 Jupyter 中了。该神器不仅对 data science 有奇效，对于一般的 python 应用开发也有极大的帮助，它同样适合用于学习 python，其易用性直追 PyCharm。&lt;/p&gt;

&lt;h1 id=&#34;bug:9efbcfe4e76745ed4d55523f6b11c597&#34;&gt;BUG？&lt;/h1&gt;

&lt;p&gt;IPython 今年初的时候就有所接触，不过用了几天就卸载了，那时用的还是 IPython notebook。昨天由于课程需要，想在本地安装 IPython。习惯性地 GOOGLE， 打开 IPython 的官网，查看安装教程 &lt;a href=&#34;https://jupyter.readthedocs.org/en/latest/install.html&#34;&gt;Installation&lt;/a&gt; ，没想到居然跳转到了 Jupyter 的文档，当时就大吃一斤，再仔细一看，尼玛连 IPython 官网的名字都变了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://ipython.org/&#34;&gt;Jupyter and the future of IPython - IPython&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一直以来就知道 python 的世界变化快，可没想到居然这么快，没几个月，项目的名称都变了。 ∑(￣□￣;)&lt;/p&gt;

&lt;p&gt;按照教程，&lt;code&gt;pip install jupyter&lt;/code&gt;，一切都很顺利，顺利到让我不敢相信，安装 python 第三方模块在我印象中都是挺蛋疼的。&lt;/p&gt;

&lt;p&gt;果不其然，安装完之后，一运行 &lt;code&gt;jupter notebook&lt;/code&gt; 就报错了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;$ jupyter notebook

Traceback (most recent call last):
  File &amp;quot;/usr/local/bin/jupyter-notebook&amp;quot;, line 11, in &amp;lt;module&amp;gt;
    sys.exit(main())
  File &amp;quot;/usr/local/lib/python2.7/dist-packages/jupyter_core/application.py&amp;quot;, line 267, in launch_instance
    return super(JupyterApp, cls).launch_instance(argv=argv, **kwargs)
  File &amp;quot;/usr/local/lib/python2.7/dist-packages/traitlets/config/application.py&amp;quot;, line 591, in launch_instance
    app.initialize(argv) File &amp;quot;&amp;lt;string&amp;gt;&amp;quot;, line 2, in initialize
  File &amp;quot;/usr/local/lib/python2.7/dist-packages/traitlets/config/application.py&amp;quot;, line 75, in catch_config_error
    return method(app, *args, **kwargs)
  File &amp;quot;/usr/local/lib/python2.7/dist-packages/notebook/notebookapp.py&amp;quot;, line 1001, in initialize
    super(NotebookApp, self).initialize(argv) File &amp;quot;&amp;lt;string&amp;gt;&amp;quot;, line 2, in initialize
  File &amp;quot;/usr/local/lib/python2.7/dist-packages/traitlets/config/application.py&amp;quot;, line 75, in catch_config_error
    return method(app, *args, **kwargs)
  File &amp;quot;/usr/local/lib/python2.7/dist-packages/jupyter_core/application.py&amp;quot;, line 243, in initialize
    self.migrate_config()
  File &amp;quot;/usr/local/lib/python2.7/dist-packages/jupyter_core/application.py&amp;quot;, line 169, in migrate_config
    migrate() 
  File &amp;quot;/usr/local/lib/python2.7/dist-packages/jupyter_core/migrate.py&amp;quot;, line 232, in migrate
    if migrate_static_custom(custom_src, custom_dst): 
  File &amp;quot;/usr/local/lib/python2.7/dist-packages/jupyter_core/migrate.py&amp;quot;, line 160, in migrate_static_custom
    if custom_css_empty:
UnboundLocalError: local variable &#39;custom_css_empty&#39; referenced before assignment
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一看有 css，直觉告诉我，可能是 Jinjia2 之类关于网页处理的模块出错了，于是卸载再重装，还是有此错误。pip 试了几遍不行，apt-get 试了几遍也不行。谷歌来谷歌去都找不到答案，项目的 issus 也翻了一遍，同样没结果，前前后后花了一个多小时，挺沮丧的。&lt;/p&gt;

&lt;h1 id=&#34;bug-fix:9efbcfe4e76745ed4d55523f6b11c597&#34;&gt;BUG fix&lt;/h1&gt;

&lt;p&gt;连重装大法都不行，这该不会是 BUG 吧？细细看了一边 traceback，再配合源码一看，立刻就知道哪里可能出错了。&lt;/p&gt;

&lt;p&gt;原来 Jupyter 在第一次运行时会检测之前是否用过 IPython，如果用过，那就把旧的配置转换成新的。把旧版 IPython 配置文件夹删了之后，再运行&lt;code&gt;jupyter notebook&lt;/code&gt;，一切正常。顺手修了这个 BUG。&lt;/p&gt;

&lt;h1 id=&#34;create-a-pull-request:9efbcfe4e76745ed4d55523f6b11c597&#34;&gt;Create a Pull Request&lt;/h1&gt;

&lt;p&gt;既然修了 BUG，那肯定要向项目开发者反馈啊，要为开源世界做贡献！ Github 主页也能好看点。 (΄◞ิ౪◟ิ‵)
过程也很简单：
 1. 创建该 BUG 的 issus（可选，建议创建）
 2. fork &lt;a href=&#34;https://github.com/jupyter/jupyter_core&#34;&gt;jupyter-core&lt;/a&gt;
 3. clone 自己的项目到本地
 4. 修补 BUG
 5. git push origin
 6. 点击项目右侧的 pull request ，创建 pull request&lt;/p&gt;

&lt;p&gt;这成了我的第一个 Pull Request。现在 jupyter-core 最新的版本是 4.0.6， 感觉这就是为我发布的。我也成了 jupyter 核心模块的贡献者，呵呵。&lt;/p&gt;

&lt;h1 id=&#34;ref:9efbcfe4e76745ed4d55523f6b11c597&#34;&gt;Ref.&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://ipython.org/&#34;&gt;https://ipython.org/&lt;/a&gt;
&lt;a href=&#34;https://jupyter.org/index.html&#34;&gt;https://jupyter.org/index.html&lt;/a&gt;
&lt;a href=&#34;https://jupyter.readthedocs.org/en/latest/install.html&#34;&gt;https://jupyter.readthedocs.org/en/latest/install.html&lt;/a&gt;
&lt;a href=&#34;https://yangsu.github.io/pull-request-tutorial/&#34;&gt;Pull Request Tutorial - A Visual Guide to Pull Requests&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;个人笔记，难免有误，如有发现，还望指出。
END.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Few words about 6.828</title>
      <link>http://neilsh.me/2015/08/30/about-6828/</link>
      <pubDate>Sun, 30 Aug 2015 15:39:38 +0800</pubDate>
      
      <guid>http://neilsh.me/2015/08/30/about-6828/</guid>
      <description>

&lt;p&gt;Recently I&amp;rsquo;ve been working on JOS, which is part of &lt;a href=&#34;http://pdos.csail.mit.edu/6.828/2014/index.html&#34;&gt;6.828: Operating System Engineering&lt;/a&gt;. 6.828 is a great course about OS, it brings principle to practice, you will implement a simple OS in this course. It also talks about the most fancy research of OS. I recommend every CS sutdent to take this course.&lt;/p&gt;

&lt;h2 id=&#34;6-828简介:1f5d1f87c04791fc85f6df330cc0063e&#34;&gt;6.828简介&lt;/h2&gt;

&lt;p&gt;好了，装逼完毕。我认真说说最近上的这门课，6.828是 MIT 开放课程中的一部分，它开放了所有关于该课程的资料，包括上课视频。我个人认为这是一门极好的关于操作系统课程，经典书籍上的知识在这将不再枯燥，它是一门操作系统课程，同时也广泛地涉及了CS中的其他内容，包括但不限于网络，安全，分布式计算等等。&lt;/p&gt;

&lt;h2 id=&#34;知新:1f5d1f87c04791fc85f6df330cc0063e&#34;&gt;知新&lt;/h2&gt;

&lt;h3 id=&#34;寻找资料的正确姿势:1f5d1f87c04791fc85f6df330cc0063e&#34;&gt;寻找资料的正确姿势&lt;/h3&gt;

&lt;p&gt;课程实验中有许多地方并没有说得很仔细，只有大概的意图，实现的细节需要你自己去查阅资料。比如说汇编里面的 &lt;code&gt;call&lt;/code&gt; &lt;code&gt;ret&lt;/code&gt; 对 &lt;code&gt;ESP&lt;/code&gt;&lt;code&gt;EBP&lt;/code&gt;&lt;code&gt;EIP&lt;/code&gt;三个寄存器的影响，它指出了这两个指令于函数调用上、传递参数有关，然后它让你写一个栈回溯函数。
Google &lt;code&gt;ret call&lt;/code&gt; 的第一个结果：&lt;a href=&#34;http://www.c-jump.com/CIS77/ASM/Procedures/P77_0010_call_ret.htm&#34;&gt;CALL and RET Instructions&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;CALL pushes the return address onto the stack and transfers control to a procedure.
RET pops the return address off the stack and returns control to that location.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;嗯，很好，把 &lt;code&gt;call&lt;/code&gt; 和 &lt;code&gt;ret&lt;/code&gt; 所干的事说了一下，但是太模糊了，比如说 return address 指向哪里，怎样来 transfers control ， pops the return address 到哪里？这些都没有说清楚。对于初学者来说，这个结果只能做参考，并不能直接拿来用。
后来经过一番查找后找到了图文并茂的资料。&lt;a href=&#34;http://unixwiz.net/techtips/win32-callconv-asm.html&#34;&gt;Intel x86 Function-call Conventions - Assembly View&lt;/a&gt; 其中 Calling a __cdecl function 那一节讲得很清楚:
&lt;img src=&#34;http://ww1.sinaimg.cn/large/7f793092gw1evo1wpue9bg20770cm3yd.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;16(%ebp) - third function parameter
12(%ebp) - second function parameter
8(%ebp)  - first function parameter&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一图胜千言，函数调用，参数传递，&lt;code&gt;ESP&lt;/code&gt;&lt;code&gt;EBP&lt;/code&gt;&lt;code&gt;EIP&lt;/code&gt;都给说明白了。对比一下前面引用的资料，完全符合。现在我们可以理解，为什么栈要从高向低生长，C 语言中参数为什么从右向左压入栈，函数内的本地变量占用的内存为什么不需要手动管理，这一切都是紧密相关的。&lt;/p&gt;

&lt;h3 id=&#34;c-的黑魔法:1f5d1f87c04791fc85f6df330cc0063e&#34;&gt;C 的黑魔法&lt;/h3&gt;

&lt;p&gt;C 语言作为入门课在大一上学期时就学了，教材是谭浩强的，他的书在网上被喷的狗血淋头，我也觉得这不是本好教材，借了本 B&amp;amp;D 的 《The C Programming Language》，囫囵吞枣地看了一遍，指针、结构体、联合体、枚举等概念倒背如流，期末的时候拿了高分，自以为 C 学得还不错。现在想来，那时还是太年轻，操作系统里漫天的指针，结构体、联合体互相的嵌套更是少不了，各种神奇的写法见都没见过。下面来几个简单的例子：&lt;/p&gt;

&lt;h4 id=&#34;给结构体初始化时给指定成员赋值:1f5d1f87c04791fc85f6df330cc0063e&#34;&gt;给结构体初始化时给指定成员赋值：&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct foo {
    int i;
    unsigned u;
    char *str;
};

int bar(void) {
    char *s = &amp;quot;Hello!&amp;quot;;
    struct foo f = {
        .str = s;
    };
    return 0; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;跨源文件调用匿名结构体变量:1f5d1f87c04791fc85f6df330cc0063e&#34;&gt;跨源文件调用匿名结构体变量：&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// 定义在 a.c 中
struct {
    int i;
    unsigned us[99];
} foo;

// 在 b.c 中
extern struct {
    int i;
    unsigned us[99];
} foo;

int bar(void) {
    printf(&amp;quot;%d\n&amp;quot;, foo.i);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;关键字-volatile:1f5d1f87c04791fc85f6df330cc0063e&#34;&gt;关键字 volatile&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;the volatile keyword indicates that a value may change between different accesses, even if it does not appear to be modified. This keyword prevents an optimizing compiler from optimizing away subsequent reads or writes and thus incorrectly reusing a stale value or omitting writes.    &amp;ndash; &lt;a href=&#34;https://en.wikipedia.org/wiki/Volatile_(computer_programming)&#34;&gt;Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;引用指出 volatile 是为了防止编译“优化”对该变量的一系列读写操作。上面抛出一大段结论，还是挺令人疑惑的。什么叫 may change between different accesses， 什么叫 optimizing away subsequent reads or writes？这一切用“底层“的汇编来解释反而容易。
&lt;a href=&#34;http://neilsh.me/assets/code/v_int.c&#34;&gt;带有 volatile&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// volatile_int.c
volatile int foo;

// 总计4次对 foo 的操作
void main(void) {
    foo = 0xff;
    printf(&amp;quot;%d\n&amp;quot;, foo);
    foo = 0xff;
    printf(&amp;quot;%d\n&amp;quot;, foo);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 编译
$ gcc -O1 volatile_int.c -o volatile_int
# 查看汇编
$ objdump -S volatile_int &amp;gt; v.asm
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;000000000040055d &amp;lt;main&amp;gt;:
  40055d:	48 83 ec 08          	sub    $0x8,%rsp
  400561:	c7 05 d9 0a 20 00 ff 	movl   $0xff,0x200ad9(%rip)        # 601044 &amp;lt;foo&amp;gt;
  400568:	00 00 00 
  40056b:	8b 15 d3 0a 20 00    	mov    0x200ad3(%rip),%edx        # 601044 &amp;lt;foo&amp;gt;
  400571:	be 34 06 40 00       	mov    $0x400634,%esi
  400576:	bf 01 00 00 00       	mov    $0x1,%edi
  40057b:	b8 00 00 00 00       	mov    $0x0,%eax
  400580:	e8 db fe ff ff       	callq  400460 &amp;lt;__printf_chk@plt&amp;gt;
  400585:	c7 05 b5 0a 20 00 ff 	movl   $0xff,0x200ab5(%rip)        # 601044 &amp;lt;foo&amp;gt;
  40058c:	00 00 00 
  40058f:	8b 15 af 0a 20 00    	mov    0x200aaf(%rip),%edx        # 601044 &amp;lt;foo&amp;gt;
  400595:	be 34 06 40 00       	mov    $0x400634,%esi
  40059a:	bf 01 00 00 00       	mov    $0x1,%edi
  40059f:	b8 00 00 00 00       	mov    $0x0,%eax
  4005a4:	e8 b7 fe ff ff       	callq  400460 &amp;lt;__printf_chk@plt&amp;gt;
  4005a9:	48 83 c4 08          	add    $0x8,%rsp
  4005ad:	c3                   	retq   
  4005ae:	66 90                	xchg   %ax,%ax
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://neilsh.me/assets/code/nv_int.c&#34;&gt;不带 volatile&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-asm&#34;&gt;000000000040055d &amp;lt;main&amp;gt;:
  40055d:	48 83 ec 08          	sub    $0x8,%rsp
  400561:	c7 05 d9 0a 20 00 ff 	movl   $0xff,0x200ad9(%rip)        # 601044 &amp;lt;foo&amp;gt;
  400568:	00 00 00 
  40056b:	ba ff 00 00 00       	mov    $0xff,%edx
  400570:	be 34 06 40 00       	mov    $0x400634,%esi
  400575:	bf 01 00 00 00       	mov    $0x1,%edi
  40057a:	b8 00 00 00 00       	mov    $0x0,%eax
  40057f:	e8 dc fe ff ff       	callq  400460 &amp;lt;__printf_chk@plt&amp;gt;
  400584:	c7 05 b6 0a 20 00 ff 	movl   $0xff,0x200ab6(%rip)        # 601044 &amp;lt;foo&amp;gt;
  40058b:	00 00 00 
  40058e:	ba ff 00 00 00       	mov    $0xff,%edx
  400593:	be 34 06 40 00       	mov    $0x400634,%esi
  400598:	bf 01 00 00 00       	mov    $0x1,%edi
  40059d:	b8 00 00 00 00       	mov    $0x0,%eax
  4005a2:	e8 b9 fe ff ff       	callq  400460 &amp;lt;__printf_chk@plt&amp;gt;
  4005a7:	48 83 c4 08          	add    $0x8,%rsp
  4005ab:	c3                   	retq   
  4005ac:	0f 1f 40 00          	nopl   0x0(%rax)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对比可见，带有 volatile 的对 foo 有四次操作，而不带的只有 2 次，从这个例子可以看出一些端倪， volatile 确保了 C 源码中每次对 foo 的操作都是直接对 foo 内存地址的操作。&lt;/p&gt;

&lt;h4 id=&#34;指针与数组:1f5d1f87c04791fc85f6df330cc0063e&#34;&gt;指针与数组&lt;/h4&gt;

&lt;p&gt;用伪码来简述一下两者的关系。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;char *pc = 0；
int *pi = 0;
int ai[5] = {0, 1, 2, 3, 4};

(pc += 1) == 1 is true;

if (sizeof(int) == 4)
    then pi + 1 == 4 is true; ((int *)pc) + 1 == 5 is true;

*ai == 0 is true

pi = ai
    then *pi == 0, pi[1] == 1, pi[4] == 4 are true;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自从学了6.828后，指针再也不是洪水猛兽，自以为余已达收发自如的境界。&lt;/p&gt;

&lt;h3 id=&#34;杂项:1f5d1f87c04791fc85f6df330cc0063e&#34;&gt;杂项&lt;/h3&gt;

&lt;p&gt;对各种计算机术语有了新的认识：process、thread、stub、trap、caller、callee、coroutine等等。
各种命令：man、git、make、gcc、objdump等等。特别是man，我还是第一次知道，man还能当编程手册，查看函数的用法。
理论与实践之间的差异，工程上的权衡于妥协。&lt;/p&gt;

&lt;h2 id=&#34;一些资源:1f5d1f87c04791fc85f6df330cc0063e&#34;&gt;一些资源&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://pdos.csail.mit.edu/6.828/2014/index.html&#34;&gt;官方网站&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/playlist?list=PLfciLKR3SgqNJKKIKUliWoNBBH1VHL3AP&#34;&gt;课程视频&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://bitbucket.org/overvenus/jos/&#34;&gt;我的 JOS (已完成lab1～6)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最后，再次感谢 MIT 的教师职员们，并以一张 JOS 靓照结尾。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/7f793092gw1evohw0nih7j20k00bw75r.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;个人笔记，难免有误，如有发现，还望指出。
END.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>