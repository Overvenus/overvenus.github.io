<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on Neil</title>
    <link>http://neilsh.me/tags/go/</link>
    <description>Recent content in Go on Neil</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Wed, 16 Mar 2016 21:49:02 +0800</lastBuildDate>
    <atom:link href="http://neilsh.me/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>理解 Goroutine &amp; Gosched</title>
      <link>http://neilsh.me/2016/03/16/understanding-of-runtime-goroutine/</link>
      <pubDate>Wed, 16 Mar 2016 21:49:02 +0800</pubDate>
      
      <guid>http://neilsh.me/2016/03/16/understanding-of-runtime-goroutine/</guid>
      <description>

&lt;h2 id=&#34;goroutine:11e673671117c063adee6332c59abd2b&#34;&gt;Goroutine&lt;/h2&gt;

&lt;p&gt;大家都知道一个编译好的 Go 程序一般都在 2MB 以上，那是因为 Go 编译器把 Go 的运行环境(runtime)也编译进去了。 一个完整的 Go 程序结构可以表示为下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/7f793092gw1f225uewt4aj20dq0af74i.jpg&#34; alt=&#34;图1&#34; /&gt;
出自 &lt;a href=&#34;http://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf&#34;&gt;7&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在 &lt;a href=&#34;http://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf&#34;&gt;Analysis of the Go runtime scheduler&lt;/a&gt; 中作者们写道：&lt;/p&gt;

&lt;p&gt;我们写的 Go 程序运行在 runtime 之上，当我们要调用 system call 时，runtime 会帮我们与系统打交道。Runtime 有一个 scheduler，它与系统的 scheduler 类似，但不同点是它调度不是系统线程而是 goroutine，而且它是运行在用户空间中（用 intel 的术语来说就是 ring3）。&lt;/p&gt;

&lt;p&gt;Goroutine 与系统线程的对应关系是 &lt;strong&gt;N:M&lt;/strong&gt;，多个goroutine对应多个系统线程，一般来说 gouroutine 的数量远多于系统线程。Goroutine 的运行依托于系统线程，一个线程在这一时刻执行的这个 goroutine，在另一时刻由于 runtime 的调度执行的可能又是另外一个 goroutine。 从系统的角度看，一个 Go 程序就是一个进程，这个进程中有多个线程，但是系统不知道也不需要知道那些线程中其实已经发生了 goroutine 调度。&lt;/p&gt;

&lt;h3 id=&#34;g-m:11e673671117c063adee6332c59abd2b&#34;&gt;g &amp;amp; m&lt;/h3&gt;

&lt;p&gt;在 Golang-nuts 上有一篇贴子 &lt;a href=&#34;https://groups.google.com/forum/#!topic/golang-nuts/SSpxrCrfvyo&#34;&gt;Understanding of runtime goroutine struct G &amp;amp; M&lt;/a&gt;. 在这篇贴子里大家讨论了 runtime 中的 &lt;code&gt;g&lt;/code&gt; 和 &lt;code&gt;m&lt;/code&gt; 结构体，这两个结构体于与 goroutine 的实现相关，简单的来说：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;一个 &lt;strong&gt;g&lt;/strong&gt; 代表一个 &lt;strong&gt;goroutine&lt;/strong&gt;，一个 &lt;strong&gt;m&lt;/strong&gt; 代表一个&lt;strong&gt;系统线程&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;g 运行在 m 中， m 中有多个 g 等待执行。 当运行着的 g 堵塞时，该 m 中剩下的 g 会自动转移到没有被堵塞的 m 中， 这样其余的 goroutine 就不会被堵塞了。当然这一切对程序员是不可见的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;p:11e673671117c063adee6332c59abd2b&#34;&gt;p&lt;/h3&gt;

&lt;p&gt;在 golang-nuts 中并没有提及另外一个重要的结构体 p， 在 &lt;a href=&#34;http://morsmachine.dk/go-scheduler&#34;&gt;morsmachine&lt;/a&gt; 的一篇博文中，他说 p 代表了处理器。
他还说一个 g 要被运行必须要有 p，整个运行结构如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/7f793092gw1f24rq6bgjjj20b40avglr.jpg&#34; alt=&#34;&#34; /&gt;
出自 &lt;a href=&#34;http://morsmachine.dk/go-scheduler&#34;&gt;8&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;每个 p 都有一个本地的 g 队列。 m + p + g 才是一个运行着的 goroutine.&lt;/p&gt;

&lt;h2 id=&#34;gosched:11e673671117c063adee6332c59abd2b&#34;&gt;Gosched&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;runtime.Gosched&lt;/code&gt; 用于让出被执行的权利，使得其他等待中的 goroutine 有机会得以执行，但这并不会终止 Gosched 的 caller。&lt;/p&gt;

&lt;p&gt;明了 Gosched 后，我们再看看它是怎么实现的。下面的 &lt;code&gt;mcall(gosched_m)&lt;/code&gt; 有点蹊跷， mcall 怎么只有一个函数签名，它的函数体在哪里？ &lt;code&gt;gosched_m&lt;/code&gt; 需要一个参数 &lt;code&gt;*g&lt;/code&gt;, 但又它在哪里呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Gosched() {
	mcall(gosched_m)
}

func mcall(fn func(*g))

// Gosched continuation on g0.
func gosched_m(gp *g) {
	if trace.enabled {
		traceGoSched()
	}
	goschedImpl(gp)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mcall:11e673671117c063adee6332c59abd2b&#34;&gt;mcall&lt;/h3&gt;

&lt;p&gt;原来 mcall 是用汇编写的， 每个平台的 mcall 实现方式都不一样。它会提供 fn 当前 goroutine 的 *g。下面我先用伪代码表示 mcall：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// mcall switches from the g to the g0 stack and invokes fn(g),
// where g is the goroutine that made the call.
// mcall saves g&#39;s current PC/SP in g-&amp;gt;sched so that it can be restored later.
// It is up to fn to arrange for that later execution, typically by recording
// g in a data structure, causing something to call ready(g) later.
// mcall returns to the original goroutine g later, when g has been rescheduled.
// fn must not return at all; typically it ends by calling schedule, to let the m
// run other goroutines.
//
// func mcall(fn func(*g))
// Switch to m-&amp;gt;g0&#39;s stack, call fn(g).
// Fn must never return.  It should gogo(&amp;amp;g-&amp;gt;sched)
// to keep running g.
func mcall(fn) {
	g = current_g
	switch stack from current_g to current_m.g0
	call fn(g)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是 mcall 的真实代码，摘取自 asm_amd64.s 文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;TEXT runtime·mcall(SB), NOSPLIT, $0-8
	MOVQ	fn+0(FP), DI
	
	get_tls(CX)
	MOVQ	g(CX), AX	// save state in g-&amp;gt;sched
	MOVQ	0(SP), BX	// caller&#39;s PC
	MOVQ	BX, (g_sched+gobuf_pc)(AX)
	LEAQ	fn+0(FP), BX	// caller&#39;s SP
	MOVQ	BX, (g_sched+gobuf_sp)(AX)
	MOVQ	AX, (g_sched+gobuf_g)(AX)
	MOVQ	BP, (g_sched+gobuf_bp)(AX)

	// switch to m-&amp;gt;g0 &amp;amp; its stack, call fn
	MOVQ	g(CX), BX
	MOVQ	g_m(BX), BX
	MOVQ	m_g0(BX), SI
	CMPQ	SI, AX	// if g == m-&amp;gt;g0 call badmcall
	JNE	3(PC)
	MOVQ	$runtime·badmcall(SB), AX
	JMP	AX
	MOVQ	SI, g(CX)	// g = m-&amp;gt;g0
	MOVQ	(g_sched+gobuf_sp)(SI), SP	// sp = m-&amp;gt;g0-&amp;gt;sched.sp
	PUSHQ	AX
	MOVQ	DI, DX
	MOVQ	0(DI), DI
	CALL	DI
	POPQ	AX
	MOVQ	$runtime·badmcall2(SB), AX
	JMP	AX
	RET
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;MOVQ&lt;/code&gt; 有点像 &lt;a href=&#34;https://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax&#34;&gt;GAS&lt;/a&gt; 汇编的风格，但为什么后面的跟着的不是 &lt;code&gt;r&lt;/code&gt; 系列的64位寄存器呢？ 还有 &lt;code&gt;FP&lt;/code&gt; 是什么东西？
虽然对于汇编我算不上熟练，但看懂，会用的程度我还是有的，这难道不是 GAS？ 赶紧 google 一下。结果还真的不是，&lt;a href=&#34;https://golang.org/doc/asm&#34;&gt;golang&lt;/a&gt; 用的是 &lt;a href=&#34;http://doc.cat-v.org/plan_9/4th_edition/papers/asm&#34;&gt;Plan 9&lt;/a&gt; 的风格。&lt;/p&gt;

&lt;p&gt;Plan 9 汇编风格和 GAS，Intel 风格最大的不同点是它有&lt;strong&gt;伪寄存器&lt;/strong&gt;，比如下面四个：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;FP: Frame pointer: arguments and locals.&lt;/li&gt;
&lt;li&gt;PC: Program counter: jumps and branches.&lt;/li&gt;
&lt;li&gt;SB: Static base pointer: global symbols.&lt;/li&gt;
&lt;li&gt;SP: Stack pointer: top of stack.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;它们用于栈的操作，具体代表什么寄存器由编译链决定，并与 CPU 的架构有关。 FP 用于取函数的参数， &lt;code&gt;0(FP)&lt;/code&gt;， &lt;code&gt;8(FP)&lt;/code&gt;分别代表第一和第二个参数(64位系统)，&lt;/p&gt;

&lt;p&gt;&lt;code&gt;TEXT runtime·mcall(SB), NOSPLIT, $0-8&lt;/code&gt; 表示这里的可执行代码为 runtime.mcall， &lt;code&gt;NOSPLIT&lt;/code&gt; 是个 flag ， &lt;code&gt;$0-8&lt;/code&gt; 0代表这个函数的 stackframe 的大小，8 代表这个函数参数们的大小，中间的 &lt;code&gt;-&lt;/code&gt; 只用于分开两者，并没有其他特殊作用。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MOVQ   fn+0(FP), DI&lt;/code&gt; 把 mcall 的参数 fn 的指针存放到 DI 中， DI 成了一个指向 fn 的指针的指针。 估计后面会有 &lt;code&gt;CALL 0(DI)&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&#34;g-to-g0:11e673671117c063adee6332c59abd2b&#34;&gt;g to g0&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;大体上 mcall 先执行栈的切换，再把当前的 g 作为参数调用 fn。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;保存当前 goroutine 的状态保存到对应的 g 中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34;&gt;MOVQ	g(CX), BX
MOVQ	g_m(BX), BX
MOVQ	0(SP), BX	// caller&#39;s PC
MOVQ	BX, (g_sched+gobuf_pc)(AX)
LEAQ	fn+0(FP), BX	// caller&#39;s SP
MOVQ	BX, (g_sched+gobuf_sp)(AX)
MOVQ	AX, (g_sched+gobuf_g)(AX)
MOVQ	BP, (g_sched+gobuf_bp)(AX)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;g_sched&lt;/code&gt; 是 &lt;a href=&#34;https://github.com/brb/go-static/blob/master/go_asm.h#L876&#34;&gt;sched&lt;/a&gt; 在 g 中的偏移量， &lt;code&gt;gobuf_pc&lt;/code&gt; 是 &lt;a href=&#34;https://github.com/golang/go/blob/master/src/runtime/runtime2.go#L293&#34;&gt;sp&lt;/a&gt; 在 sched 中的 gobuf 的偏移量，依此类推。它们定义在 go_asm.h 文件中。 执行完后，当前 goroutine 的状态将会存放到对应的 g.sched 中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#ifdef GOARCH_amd64
#define	get_tls(r)	MOVQ TLS, r
#define	g(r)	0(r)(TLS*1)
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;get_tls(r)&lt;/code&gt; 是一个宏，定义在 go_tls.h 文件中，它的作用是把当前的 goroutine 的 &lt;em&gt;g&lt;/em&gt; 的指针的地址存到指定的寄存器中（有点绕 - -）。 比如: &lt;code&gt;get_tls(CX)&lt;/code&gt;， CX 中的将会存有当前 g 的地址。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;g(r)&lt;/code&gt; 用于 dereference the pointer of g pointer (实在想不出好的翻译), 比如: &lt;code&gt;g(CX)&lt;/code&gt;, 最终会得到 &lt;code&gt;0(r)(TLS*1)&lt;/code&gt;，解了一层引用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34;&gt;MOVQ	m_g0(BX), SI
MOVQ	SI, g(CX)	// g = m-&amp;gt;g0
MOVQ	(g_sched+gobuf_sp)(SI), SP	// sp = m-&amp;gt;g0-&amp;gt;sched.sp
PUSHQ	AX
MOVQ	DI, DX
MOVQ	0(DI), DI
CALL	DI
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这段代码先把 m.g0 变成 g， 再进行栈的切换，然后把先前 的 g 做为参数推入栈，最后调用 fn。 就这样，mcall 完成了 goroutine 栈的切换并将先前的 g 传入了 fn。&lt;/p&gt;

&lt;p&gt;值得一提的是，几乎的所有汇编文件中都 include 的 go_asm.h， 这个头文件在 golang 的源码中并不存在，它是在编译时&lt;a href=&#34;https://groups.google.com/d/msg/golang-nuts/nRMMvHxsyYQ/n4kLtIHwCAAJ&#34;&gt;自动生成&lt;/a&gt;。 Github 上有一个生成好的 go_asm.h，是 Linux Amd64 的， 有兴趣的同学可以去看一下，&lt;a href=&#34;https://github.com/brb/go-static/blob/master/go_asm.h#L876&#34;&gt;链接在此&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;下面是 g.sched 的具体内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type gobuf struct {
	// The offsets of sp, pc, and g are known to (hard-coded in) libmach.
	sp   uintptr
	pc   uintptr
	g    guintptr
	ctxt unsafe.Pointer // this has to be a pointer so that gc scans it
	ret  uintreg
	lr   uintptr
	bp   uintptr // for GOEXPERIMENT=framepointer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里或许会有点疑问，mcall 保存这么点东西真的足够代表 goroutine 的状态吗？唉，还别说，足够了。 Goroutine 和系统线程不同，一个程序的 Goroutine 全部运行在同一个用户空间，这就意味着没有必要 trap 到 rang0，切换 PageTable(cr3) 或使 TLB 失效。 不过还有一个问题：寄存器的状态呢？确实寄存器的状态是 context 切换的关键点之一。但是不要忘了，这里是调用函数，在调用函数之前一般会把有用的寄存器存到栈中。还是不放心的话，我们来看看真实世界中的 Gosched， 我写了一个简单的例子，并用 go tool compile 获取了它的汇编代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;runtime&amp;quot;

func g1() {
	i := 0
	for {
		i++
		runtime.Gosched()
	}
}

func g2() {
	i, j := 0, 0
	for {
		i++
		runtime.Gosched()
		j += i
	}
}

func main() {
	go g1()
	go g2()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在命令台中输入:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ go build sample.go
$ go tool objdump sample &amp;gt; sample.asm # 汇编代码
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是 g1 的汇编：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34;&gt;sample.go:8	0x401015	4889c3			MOVQ AX, BX    // for loop
sample.go:8	0x401018	48ffc3			INCQ BX        // i++
sample.go:8	0x40101b	48891c24		MOVQ BX, 0(SP) // push i
sample.go:9	0x40101f	e89c2b0200		CALL runtime.Gosched(SB)
sample.go:9	0x401024	488b0424		MOVQ 0(SP), AX // pop i
sample.go:8	0x401028	ebeb			JMP 0x401015   // again
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看见在这段代码中 BX 是那个 &lt;strong&gt;i&lt;/strong&gt;，在这里需要保存的只有 BX，而在 Gosched 之前和之后都有 BX 的栈处理。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34;&gt;sample.go:16	0x40105d	4889cb			MOVQ CX, BX
sample.go:16	0x401060	48ffc3			INCQ BX
sample.go:16	0x401063	48895c2408		MOVQ BX, 0x8(SP)
sample.go:17	0x401068	e8532b0200		CALL runtime.Gosched(SB)
sample.go:17	0x40106d	488b4c2408		MOVQ 0x8(SP), CX
sample.go:18	0x401072	488b1c24		MOVQ 0(SP), BX
sample.go:18	0x401076	4801cb			ADDQ CX, BX
sample.go:18	0x401079	48891c24		MOVQ BX, 0(SP)
sample.go:16	0x40107d	ebde			JMP 0x40105d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同上， g2 在 Gosched 之前，会保存关键的寄存器。&lt;/p&gt;

&lt;p&gt;就像 &lt;a href=&#34;http://doc.cat-v.org/plan_9/4th_edition/papers/asm&#34;&gt;A Manual for the Plan 9 assembler&lt;/a&gt; 所说：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A subroutine is responsible for saving its own registers, and therefore is free to use any registers without saving them (‘‘caller saves’’)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;gogo:11e673671117c063adee6332c59abd2b&#34;&gt;gogo&lt;/h3&gt;

&lt;p&gt;mcall 中保存的信息会在后来的 gogo 中恢复到 g 中，下面的代码摘自 asm_amd64.s。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// void gogo(Gobuf*)
// restore state from Gobuf; longjmp
TEXT runtime·gogo(SB), NOSPLIT, $0-8
	MOVQ	buf+0(FP), BX		// gobuf
	MOVQ	gobuf_g(BX), DX
	MOVQ	0(DX), CX		// make sure g != nil
	get_tls(CX)
	MOVQ	DX, g(CX)
	MOVQ	gobuf_sp(BX), SP	// restore SP
	MOVQ	gobuf_ret(BX), AX
	MOVQ	gobuf_ctxt(BX), DX
	MOVQ	gobuf_bp(BX), BP
	MOVQ	$0, gobuf_sp(BX)	// clear to help garbage collector
	MOVQ	$0, gobuf_ret(BX)
	MOVQ	$0, gobuf_ctxt(BX)
	MOVQ	$0, gobuf_bp(BX)
	MOVQ	gobuf_pc(BX), BX
	JMP	BX
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于 g1, 在 &lt;code&gt;JMP BX&lt;/code&gt; 之后， PC 回到了 &lt;code&gt;0x401024&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;过程:11e673671117c063adee6332c59abd2b&#34;&gt;过程&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;             g
             $
             $          g0
 Gosched --&amp;gt; $ -------&amp;gt; $
                mcall   $
                        $
           schedule --&amp;gt; $
                        $         g&#39;
            execute --&amp;gt; $ ------&amp;gt; $
                           gogo   $
                                  $
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Gosched 的大致过程就像如上面所示， $ 代表 thread of execution，第一条为 g， 第二条是 g0，第三条是调度时被选中执行的 g&amp;rsquo;。&lt;/p&gt;

&lt;h3 id=&#34;schedule:11e673671117c063adee6332c59abd2b&#34;&gt;schedule&lt;/h3&gt;

&lt;p&gt;完整的 schedule 有许多情况要处理，写得有点复杂，简明起见，我只摘录了关键代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func schedule() {
	_g_ := getg()
	if _g_.m.p.ptr().schedtick%61 == 0 &amp;amp;&amp;amp; sched.runqsize &amp;gt; 0 {
		lock(&amp;amp;sched.lock)
		gp = globrunqget(_g_.m.p.ptr(), 1)
		unlock(&amp;amp;sched.lock)
		if gp != nil {
			resetspinning()
		}
	}
	if gp == nil {
		gp, inheritTime = runqget(_g_.m.p.ptr())
		if gp != nil &amp;amp;&amp;amp; _g_.m.spinning {
			throw(&amp;quot;schedule: spinning with local work&amp;quot;)
		}
	}
	if gp == nil {
		gp, inheritTime = findrunnable() // blocks until work is available
		resetspinning()
	}
	execute(gp, inheritTime)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个 if 每隔一段时间会首先运行 globrunqueue 中的 g，这是保证了公平，否则的话只要一个 q localrunqueue 中有两个可运行 g，那么这个 m 就会一直被这两个 g 占据着。&lt;/p&gt;

&lt;p&gt;第二个 if 从 q 本地取一个 g 运行。&lt;/p&gt;

&lt;p&gt;第三个 if 从 globrunqueue 或者其他 p 中取 g，这使得在本地没有可以运行的 g 或没从 globrunqueue 取或 globrunqueue 也没有时，也有 g 可以运行。&lt;/p&gt;

&lt;p&gt;同时这也验证了上面的那幅图片。&lt;/p&gt;

&lt;h2 id=&#34;链接:11e673671117c063adee6332c59abd2b&#34;&gt;链接&lt;/h2&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://groups.google.com/forum/#!topic/golang-nuts/SSpxrCrfvyo&#34;&gt;Understanding of runtime goroutine struct G &amp;amp; M&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax&#34;&gt;X86 Assembly/GAS Syntax&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://golang.org/doc/asm&#34;&gt;A Quick Guide to Go&amp;rsquo;s Assembler&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://doc.cat-v.org/plan_9/4th_edition/papers/asm&#34;&gt;A Manual for the Plan 9 assembler&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://groups.google.com/d/msg/golang-nuts/nRMMvHxsyYQ/n4kLtIHwCAAJ&#34;&gt;Accessing go internals from asm, how to generate go_asm.h?&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/brb/go-static/blob/master/go_asm.h#L876&#34;&gt;go-static/go_asm.h at master · brb/go-static&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/master/src/runtime/runtime2.go#L293&#34;&gt;Analysis of the Go runtime scheduler&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw&#34;&gt;The Go scheduler&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://morsmachine.dk/go-scheduler&#34;&gt;go/runtime2.go at master · golang/go&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw&#34;&gt;Scalable Go Scheduler Design Doc&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;!-- links --&gt;
</description>
    </item>
    
    <item>
      <title>Introducing Slender-Next</title>
      <link>http://neilsh.me/2016/02/23/introducing-slender-next/</link>
      <pubDate>Tue, 23 Feb 2016 14:25:32 +0800</pubDate>
      
      <guid>http://neilsh.me/2016/02/23/introducing-slender-next/</guid>
      <description>

&lt;h2 id=&#34;slender-next:3c4e2d208ca79d5efa86c04d997b2fbe&#34;&gt;Slender-Next&lt;/h2&gt;

&lt;p&gt;Yet another sample theme for &lt;a href=&#34;http://gohugo.io/&#34;&gt;Hugo&lt;/a&gt; with &lt;a href=&#34;https://github.com/chriskempson/base16&#34;&gt;base16&lt;/a&gt; color schemes.&lt;/p&gt;

&lt;p&gt;Based on &lt;a href=&#34;https://github.com/CrimsonRay/slender&#34;&gt;slender&lt;/a&gt;, inspired by &lt;a href=&#34;https://github.com/iissnan/hexo-theme-next&#34;&gt;hexo-theme-next&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;screenshot:3c4e2d208ca79d5efa86c04d997b2fbe&#34;&gt;Screenshot&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://neilsh.me/assets/img/slender-next/screenshot.png&#34; alt=&#34;screenshot&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;features:3c4e2d208ca79d5efa86c04d997b2fbe&#34;&gt;Features&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Responsive&lt;/li&gt;
&lt;li&gt;Pagination&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/chriskempson/base16&#34;&gt;base16&lt;/a&gt; color schemes&lt;/li&gt;
&lt;li&gt;Code/syntax highlighting with &lt;a href=&#34;https://highlightjs.org/&#34;&gt;highlight.js 9.1.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Proper meta tags for SEO&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Optimized for China&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Google Analytics And Baidu Tongji integration&lt;/li&gt;
&lt;li&gt;Disqus And Duoshuo integration&lt;/li&gt;
&lt;li&gt;MathJax support&lt;/li&gt;
&lt;li&gt;Table of Content&lt;/li&gt;
&lt;li&gt;Tags + Archive&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;color-schemes:3c4e2d208ca79d5efa86c04d997b2fbe&#34;&gt;Color Schemes&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://neilsh.me/assets/img/slender-next/slender-color-schemes.png&#34; alt=&#34;slender-color-schemes&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;installation:3c4e2d208ca79d5efa86c04d997b2fbe&#34;&gt;Installation&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Make a new Hugo site&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;$ hugo new site your_site/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Install Slender&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;$ cd your_site/
$ mkdir themes
$ cd themes
$ git clone https://github.com/overvenus/slender-next
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;configuration:3c4e2d208ca79d5efa86c04d997b2fbe&#34;&gt;Configuration&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# config.toml
# https://github.com/overvenus/slender-next

baseurl = &amp;quot;http://url-to-your-site.com/&amp;quot;
title = &amp;quot;Your Title&amp;quot;
# set &amp;quot;zh-Hans&amp;quot;, turn on optimization.
languageCode = &amp;quot;en-US&amp;quot;
MetaDataFormat = &amp;quot;yaml&amp;quot;
theme = &amp;quot;slender-next&amp;quot;
paginate = 5
PaginatePath = &amp;quot;/page/&amp;quot;

[author]
    name = &amp;quot;Your Name&amp;quot;

[permalinks]

    # Permalink format for pages.
    page = &amp;quot;/:title/&amp;quot;

    # Permalink format for blog posts.
    post = &amp;quot;/:year/:month/:day/:title/&amp;quot;

[taxonomies]
    # tags -&amp;gt; menu.main.tags
    tag = &amp;quot;tags&amp;quot;
    # archive -&amp;gt; menu.main.archive
    archive = &amp;quot;archive&amp;quot;

[params]

    # Change the color scheme of Slender.
    # See above for preview and list of color schemes.
    colorscheme = &amp;quot;white&amp;quot;

    # Tagline; HTML accepted here. Keep it concise.
    tagline = &amp;quot;Your Tagline&amp;quot;

    # copyright, see http://creativecommons.org/
    licenses = &amp;quot;BY-NC-SA&amp;quot;

    # Description and keywords for &amp;lt;meta&amp;gt; tags.
    # Remember to set this for your main page.
    # This will be overridden by whatever is set by the page or post,
    # defined by `description` and `keywords` variables in the front matter
    # of the markdown file.
    description = &amp;quot;Default Page Description&amp;quot;
    keywords = &amp;quot;default,page,keywords&amp;quot;

    # Analytics
    # Remove, comment, or leave it blank if you don&#39;t have one.
    googleAnalytics = &amp;quot;GoogleAnalyticsParams&amp;quot;
    baiduTongji = &amp;quot;BaiduTongji&amp;quot;

    # Comment
    # Remove or comment if you don&#39;t have one.
    # if both set,
    #    zh-Hans: duoshuoShortname &amp;gt; disqusShortname
    #    else: disqusShortname &amp;gt; duoshuoShortname
    duoshuoShortname = &amp;quot;your-duoshuo&amp;quot;
    disqusShortname = &amp;quot;you-disqus&amp;quot;

    # MathJax
    # see: http://mathjax.readthedocs.org/en/latest/options/hub.html
    mathjax = true # enable
    mathHideMenu = false
    mathZoom = &amp;quot;Double-Click&amp;quot;
    mathRenderer = &amp;quot;SVG&amp;quot;

[menu]

    # Menu for the nav bar.
    # There must always be one item present (e.g. home).
    # identifier: Font Awesome icon name
    [[menu.main]]
    identifier = &amp;quot;fa-home&amp;quot;
    name       = &amp;quot;Home&amp;quot;
    url        = &amp;quot;/&amp;quot;
    weight     = 0

    [[menu.main]]
    identifier = &amp;quot;fa-user&amp;quot;
    name       = &amp;quot;About&amp;quot;
    url        = &amp;quot;/about/&amp;quot;
    weight     = 1

    [[menu.main]]
    identifier = &amp;quot;fa-archive&amp;quot;
    name       = &amp;quot;Archive&amp;quot;
    url        = &amp;quot;/archive/&amp;quot;
    weight     = 2

    [[menu.main]]
    identifier = &amp;quot;fa-tags&amp;quot;
    name       = &amp;quot;Tags&amp;quot;
    url        = &amp;quot;/tags/&amp;quot;
    weight     = 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;usage:3c4e2d208ca79d5efa86c04d997b2fbe&#34;&gt;Usage&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Making a new post / article&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;$ hugo new post/hello.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Making a new page&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;$ hugo new page/about.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add the new page to navbar in &lt;code&gt;config.toml&lt;/code&gt; under &lt;code&gt;[menu]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Turn on MathJax&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Post&amp;rsquo;s front matter. Default: &amp;ldquo;off&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
mathjax: &amp;quot;on&amp;quot;
---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Turn off TOC&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Post&amp;rsquo;s front matter. Default: &amp;ldquo;on&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
toc: &amp;quot;off&amp;quot;
---
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;license:3c4e2d208ca79d5efa86c04d997b2fbe&#34;&gt;License&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;LICENSE.md&#34;&gt;MIT&lt;/a&gt; &amp;copy; 2015 CrimsonRay&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;LICENSE.md&#34;&gt;MIT&lt;/a&gt; &amp;copy; 2016 Neil Shen&lt;/p&gt;

&lt;h2 id=&#34;get-it-now:3c4e2d208ca79d5efa86c04d997b2fbe&#34;&gt;Get it NOW!&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/overvenus/slender-next&#34;&gt;Slender-Next&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>make slice map channel</title>
      <link>http://neilsh.me/2015/11/09/make-slice-map-channel/</link>
      <pubDate>Mon, 09 Nov 2015 15:16:55 +0800</pubDate>
      
      <guid>http://neilsh.me/2015/11/09/make-slice-map-channel/</guid>
      <description>

&lt;h2 id=&#34;where-is-the-make-implemention:f54eeb4205b24658133f3791bb00140a&#34;&gt;Where is the make implemention?&lt;/h2&gt;

&lt;p&gt;package &lt;strong&gt;runtime&lt;/strong&gt;
By the way, &lt;em&gt;new&lt;/em&gt;, &lt;em&gt;map&lt;/em&gt;, &lt;em&gt;slice&lt;/em&gt;, &lt;em&gt;channel&lt;/em&gt;, &lt;em&gt;goroutine&lt;/em&gt; and &lt;em&gt;garbage collector&lt;/em&gt;[&lt;a href=&#34;https://docs.google.com/document/d/1P3BLR31VA8cvLJLfMibSuTdwTuF7WWLux71CYD0eeD8&#34;&gt;1&lt;/a&gt;] are also implemented in this package.&lt;/p&gt;

&lt;h2 id=&#34;slices:f54eeb4205b24658133f3791bb00140a&#34;&gt;Slices&lt;/h2&gt;

&lt;p&gt;Source file: go/src/runtime/slice.go&lt;/p&gt;

&lt;h3 id=&#34;data-structure:f54eeb4205b24658133f3791bb00140a&#34;&gt;Data structure&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Underlying data structure of &lt;strong&gt;slice&lt;/strong&gt; is trival. Go is statically typed, and why this litte struct can be the template of any type of slices? Well, look at the comments of &lt;code&gt;unsafe.Pointer&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Pointer represents a pointer to an arbitrary type.  There are four special operations
// available for type Pointer that are not available for other types.
//  1) A pointer value of any type can be converted to a Pointer.
//  2) A Pointer can be converted to a pointer value of any type.  &amp;lt;-- here!
//  3) A uintptr can be converted to a Pointer.
//  4) A Pointer can be converted to a uintptr.
// Pointer therefore allows a program to defeat the type system and read and write
// arbitrary memory. It should be used with extreme care.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, &lt;strong&gt;Pointer&lt;/strong&gt; in Go is &lt;strong&gt;*void&lt;/strong&gt; in C. &lt;em&gt;Pointer&lt;/em&gt; anesthetizes the type system and read and write arbitrary memory in Go. &lt;em&gt;*void&lt;/em&gt; can be converted to any type without warning in C.&lt;/p&gt;

&lt;h3 id=&#34;make-slices:f54eeb4205b24658133f3791bb00140a&#34;&gt;Make slices&lt;/h3&gt;

&lt;p&gt;Make slices is trival.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// TODO: take uintptrs instead of int64s?
func makeslice(t *slicetype, len64, cap64 int64) slice {
    // NOTE: The len &amp;gt; MaxMem/elemsize check here is not strictly necessary,
    // but it produces a &#39;len out of range&#39; error instead of a &#39;cap out of range&#39; error
    // when someone does make([]T, bignumber). &#39;cap out of range&#39; is true too,
    // but since the cap is only being supplied implicitly, saying len is clearer.
    // See issue 4085.
    len := int(len64)
    if len64 &amp;lt; 0 || int64(len) != len64 || t.elem.size &amp;gt; 0 &amp;amp;&amp;amp; uintptr(len) &amp;gt; _MaxMem/uintptr(t.elem.size) {
        panic(errorString(&amp;quot;makeslice: len out of range&amp;quot;))
    }
    cap := int(cap64)
    if cap &amp;lt; len || int64(cap) != cap64 || t.elem.size &amp;gt; 0 &amp;amp;&amp;amp; uintptr(cap) &amp;gt; _MaxMem/uintptr(t.elem.size) {
        panic(errorString(&amp;quot;makeslice: cap out of range&amp;quot;))
    }
    p := newarray(t.elem, uintptr(cap))
    return slice{p, len, cap}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, a slice is always 24 bytes(amd64, ubuntu 14.04 LTS), no matter how many elements it has or how much capacity it is. The actual data that a slice represents locate in other place, not in the slice itself. More details about slice can be found in [&lt;a href=&#34;https://gist.github.com/Overvenus/f6cf225ec33cc98d6b8c&#34;&gt;3&lt;/a&gt;] and [&lt;a href=&#34;https://blog.golang.org/go-slices-usage-and-internals&#34;&gt;4&lt;/a&gt;].&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;newarray&lt;/strong&gt; eventually calls &lt;strong&gt;mallocgc&lt;/strong&gt;, which will allocate memory in heap(for big array) or per-thread cache (for small array) [&lt;a href=&#34;http://goog-perftools.sourceforge.net/doc/tcmalloc.html&#34;&gt;2&lt;/a&gt;].&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// implementation of make builtin for slices
func newarray(typ *_type, n uintptr) unsafe.Pointer {
    flags := uint32(0)
    if typ.kind&amp;amp;kindNoPointers != 0 {
        flags |= flagNoScan
    }
    if int(n) &amp;lt; 0 || (typ.size &amp;gt; 0 &amp;amp;&amp;amp; n &amp;gt; _MaxMem/uintptr(typ.size)) {
        panic(&amp;quot;runtime: allocation size out of range&amp;quot;)
    }
    return mallocgc(uintptr(typ.size)*n, typ, flags)
    /*                               ^^  multiply size by n  */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;maps:f54eeb4205b24658133f3791bb00140a&#34;&gt;Maps&lt;/h2&gt;

&lt;p&gt;Source file: go/src/runtime/hashmap.go&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;// A map is just a hash table.  The data is arranged
// into an array of buckets.  Each bucket contains up to
// 8 key/value pairs.  The low-order bits of the hash are
// used to select a bucket.  Each bucket contains a few
// high-order bits of each hash to distinguish the entries
// within a single bucket.
//
// If more than 8 keys hash to a bucket, we chain on
// extra buckets.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;data-structure-1:f54eeb4205b24658133f3791bb00140a&#34;&gt;Data structure&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// A header for a Go map.
type hmap struct {
    // Note: the format of the Hmap is encoded in ../../cmd/internal/gc/reflect.go and
    // ../reflect/type.go.  Don&#39;t change this structure without also changing that code!
    count int // # live cells == size of map.  Must be first (used by len() builtin)
    flags uint8
    B     uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)
    hash0 uint32 // hash seed

    buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.
    oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing
    nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)

    // If both key and value do not contain pointers and are inline, then we mark bucket
    // type as containing no pointers. This avoids scanning such maps.
    // However, bmap.overflow is a pointer. In order to keep overflow buckets
    // alive, we store pointers to all overflow buckets in hmap.overflow.
    // Overflow is used only if key and value do not contain pointers.
    // overflow[0] contains overflow buckets for hmap.buckets.
    // overflow[1] contains overflow buckets for hmap.oldbuckets.
    // The first indirection allows us to reduce static size of hmap.
    // The second indirection allows to store a pointer to the slice in hiter.
    overflow *[2]*[]*bmap
}

// A bucket for a Go map.
type bmap struct {
    tophash [bucketCnt]uint8
    // Followed by bucketCnt keys and then bucketCnt values.
    // NOTE: packing all the keys together and then all the values together makes the
    // code a bit more complicated than alternating key/value/key/value/... but it allows
    // us to eliminate padding which would be needed for, e.g., map[int64]int8.
    // Followed by an overflow pointer.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;make-maps:f54eeb4205b24658133f3791bb00140a&#34;&gt;Make maps&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// makemap implements a Go map creation make(map[k]v, hint)
// If the compiler has determined that the map or the first bucket
// can be created on the stack, h and/or bucket may be non-nil.
// If h != nil, the map can be created directly in h.
// If bucket != nil, bucket can be used as the first bucket.
func makemap(t *maptype, hint int64, h *hmap, bucket unsafe.Pointer) *hmap {
    if !ismapkey(t.key) {                             /* pointer --&amp;gt; ^^^^^ */
        throw(&amp;quot;runtime.makemap: unsupported map key type&amp;quot;)
    }

    /* I delete some checks */

    // make sure zeroptr is large enough
    mapzero(t.elem)

    // find size parameter which will hold the requested # of elements
    B := uint8(0)
    for ; hint &amp;gt; bucketCnt &amp;amp;&amp;amp; float32(hint) &amp;gt; loadFactor*float32(uintptr(1)&amp;lt;&amp;lt;B); B++ {
    }

    // allocate initial hash table
    // if B == 0, the buckets field is allocated lazily later (in mapassign)
    // If hint is large zeroing this memory could take a while.
    buckets := bucket
    if B != 0 {
        buckets = newarray(t.bucket, uintptr(1)&amp;lt;&amp;lt;B)
    }

    // initialize Hmap
    if h == nil {
        h = (*hmap)(newobject(t.hmap))  /*  */
    }
    h.count = 0
    h.B = B
    h.flags = 0
    h.hash0 = fastrand1()
    h.buckets = buckets
    h.oldbuckets = nil
    h.nevacuate = 0

    return h
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A map is always 8 bytes(amd64, ubuntu 14.04 LTS), because &lt;code&gt;makemap&lt;/code&gt; returns a poniter, ponites to hmap, the underlying data sturcture is allocated in heap.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// implementation of new builtin
func newobject(typ *_type) unsafe.Pointer {
    flags := uint32(0)
    if typ.kind&amp;amp;kindNoPointers != 0 {
        flags |= flagNoScan
    }
    return mallocgc(uintptr(typ.size), typ, flags)
    /* compares with newarray, no multiplication */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is worth nothing that &lt;code&gt;v, ok := map[k]&lt;/code&gt; and &lt;code&gt;v := map[k]&lt;/code&gt; are also implemented in this file.&lt;/p&gt;

&lt;h2 id=&#34;channel:f54eeb4205b24658133f3791bb00140a&#34;&gt;Channel&lt;/h2&gt;

&lt;p&gt;source file: go/src/runtime/channel.go&lt;/p&gt;

&lt;h3 id=&#34;data-structure-2:f54eeb4205b24658133f3791bb00140a&#34;&gt;Data structure&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;type hchan struct {
    qcount   uint           // total data in the queue
    dataqsiz uint           // size of the circular queue
    buf      unsafe.Pointer // points to an array of dataqsiz elements
    elemsize uint16
    closed   uint32
    elemtype *_type // element type
    sendx    uint   // send index
    recvx    uint   // receive index
    recvq    waitq  // list of recv waiters
    sendq    waitq  // list of send waiters
    lock     mutex
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;make-chan:f54eeb4205b24658133f3791bb00140a&#34;&gt;Make chan&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;func makechan(t *chantype, size int64) *hchan {
    elem := t.elem

    /* I delete some checks */

    var c *hchan
    if elem.kind&amp;amp;kindNoPointers != 0 || size == 0 {
        // Allocate memory in one call.
        // Hchan does not contain pointers interesting for GC in this case:
        // buf points into the same allocation, elemtype is persistent.
        // SudoG&#39;s are referenced from their owning thread so they can&#39;t be collected.
        // TODO(dvyukov,rlh): Rethink when collector can move allocated objects.
        c = (*hchan)(mallocgc(hchanSize+uintptr(size)*uintptr(elem.size), nil, flagNoScan))
        if size &amp;gt; 0 &amp;amp;&amp;amp; elem.size != 0 {
            c.buf = add(unsafe.Pointer(c), hchanSize)
        } else {
            // race detector uses this location for synchronization
            // Also prevents us from pointing beyond the allocation (see issue 9401).
            c.buf = unsafe.Pointer(c)
        }
    } else {
        c = new(hchan)
        c.buf = newarray(elem, uintptr(size))
    }
    c.elemsize = uint16(elem.size)
    c.elemtype = elem
    c.dataqsiz = uint(size)

    if debugChan {
        print(&amp;quot;makechan: chan=&amp;quot;, c, &amp;quot;; elemsize=&amp;quot;, elem.size, &amp;quot;; elemalg=&amp;quot;, elem.alg, &amp;quot;; dataqsiz=&amp;quot;, size, &amp;quot;\n&amp;quot;)
    }
    return c
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A channel variable at runtime(not package) is very much like a map variable, they are both pointers, pointes to heap.&lt;/p&gt;

&lt;h2 id=&#34;make-gist:f54eeb4205b24658133f3791bb00140a&#34;&gt;Make gist&lt;/h2&gt;

&lt;p&gt;I wrote a gist to uncover slice, map and channel at runtime(not package)&lt;a href=&#34;http://goog-perftools.sourceforge.net/doc/tcmalloc.html&#34;&gt;2&lt;/a&gt;.&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/Overvenus/f6cf225ec33cc98d6b8c.js&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;outputs-in-my-laptop:f54eeb4205b24658133f3791bb00140a&#34;&gt;Outputs in my laptop&lt;/h3&gt;

&lt;p&gt;Env: Ubuntu 14.04 LTS, amd64&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go run make.go
GOOS linux
GOARCH amd64
--- array &amp;amp; slice ---
si: type: [100]int
si: sizeof: 800
si: address 1st ele.: 0xc820062380
---
asi:    type: *[100]int
asi:    sizeof: 8
asi:    address: 0xc820062380
asi:    address 1st ele.: 0xc820062380
---
si[:20]:    type: []int
si[:20]:    sizeof: 24
si[:20]:    address 1st ele.: 0xc820062380
---
si[:80]:    type: []int
si[:80]:    sizeof: 24
si[:80]:    address 1st ele.: 0xc820062380
---
assi:   type: *[]int
assi:   sizeof: 8
assi:   address: 0xc8200105e0
--- map ---
m:  type: map[int]int
m:  sizeof: 8
---
am: type: *map[int]int
am: sizeof: 8
--- channel ---
ci: type: chan int
ci: sizeof: 8
---
aci:    type: *chan int
aci:    sizeof: 8
---
ci: type: chan int
ci: sizeof: 8
---
abci:   type: *chan int
abci:   sizeof: 8
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;links:f54eeb4205b24658133f3791bb00140a&#34;&gt;Links&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;[1], &lt;a href=&#34;https://docs.google.com/document/d/1P3BLR31VA8cvLJLfMibSuTdwTuF7WWLux71CYD0eeD8&#34;&gt;Go 1.3+ Compiler Overhaul&lt;/a&gt;
[2], &lt;a href=&#34;http://goog-perftools.sourceforge.net/doc/tcmalloc.html&#34;&gt;TCMalloc : Thread-Caching Malloc&lt;/a&gt;
[3], &lt;a href=&#34;https://gist.github.com/Overvenus/f6cf225ec33cc98d6b8c&#34;&gt;slice, map and channel at runtime&lt;/a&gt;
[4], &lt;a href=&#34;https://blog.golang.org/go-slices-usage-and-internals&#34;&gt;Go Slices: usage and internals&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;End.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go Note</title>
      <link>http://neilsh.me/2015/10/08/golang-note/</link>
      <pubDate>Thu, 08 Oct 2015 22:03:01 +0800</pubDate>
      
      <guid>http://neilsh.me/2015/10/08/golang-note/</guid>
      <description>

&lt;!--
TODO:
   - ...
--&gt;

&lt;h2 id=&#34;new-make-and-local-variable:29d085475296ad0ae0e08e9c74a587d0&#34;&gt;&lt;code&gt;new&lt;/code&gt;, &lt;code&gt;make&lt;/code&gt; and Local variable&lt;/h2&gt;

&lt;p&gt;In short: new allocates memory; make initializes the slice, map, and channel types; local variable may be not &lt;em&gt;local&lt;/em&gt; at all.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;new&lt;/code&gt;: new(T) allocates zeroed storage for a new item of type T and returns its address, a value of type *T. In Go terminology, it returns a pointer to a newly allocated zero value of type T.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;make&lt;/code&gt;: creates slices, maps, and channels only, and it returns an &lt;em&gt;initialized (not zeroed)&lt;/em&gt; value of type T (not *T).&lt;/p&gt;

&lt;p&gt;Local variable: unlike in C, it&amp;rsquo;s perfectly OK to return the address of a local variable; the storage associated with the variable survives after the function returns. In fact, taking the address of a composite literal allocates a fresh instance each time it is evaluated, so we can combine these last two lines. (e.g., &lt;code&gt;return &amp;amp;File{fd: fd, name: name}&lt;/code&gt;)
 &amp;ndash; &lt;a href=&#34;https://golang.org/doc/effective_go.html#allocation_new&#34;&gt;Effective GO#allocation_new&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;stack-or-heap:29d085475296ad0ae0e08e9c74a587d0&#34;&gt;Stack or Heap?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/doc/faq#stack_or_heap&#34;&gt;Golang FAQ#stackheap&lt;/a&gt;
&lt;strong&gt;How do I know whether a variable is allocated on the heap or the stack?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;From a correctness standpoint, you don&amp;rsquo;t need to know. Each variable in Go exists as long as there are &lt;em&gt;references&lt;/em&gt; to it. The storage location chosen by the implementation is irrelevant to the semantics of the language.&lt;/p&gt;

&lt;p&gt;The storage location does have an effect on writing efficient programs. When possible, the Go compilers will allocate variables that are local to a function in that function&amp;rsquo;s stack frame. However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors. Also, if a local variable is very large, it might make more sense to store it on the heap rather than the stack.&lt;/p&gt;

&lt;p&gt;In the current compilers, if a variable has its address taken, that variable is a candidate for allocation on the heap. However, a basic escape analysis recognizes some cases when such variables will not live past the return from the function and can reside on the stack.&lt;/p&gt;

&lt;p&gt;An excellent talk about stack and heap of Go. &lt;a href=&#34;http://dave.cheney.net/2014/06/07/five-things-that-make-go-fast&#34;&gt;Five things that make Go fast&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;happen-before-and-channel:29d085475296ad0ae0e08e9c74a587d0&#34;&gt;Happen before and Channel&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/ref/mem#tmp_7&#34;&gt;Golang Memory Model#channel&lt;/a&gt;
&amp;gt; A send on a channel happens before the corresponding receive from that channel completes.&lt;/p&gt;

&lt;p&gt;An interesting case where &lt;em&gt;Happen Before&lt;/em&gt; will take place.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var c = make(chan int)
var a string

func f() {
    a = &amp;quot;hello, world&amp;quot;
    &amp;lt;-c
}
func main() {
    go f()
    c &amp;lt;- 0
    print(a)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This snippet guarantes to print &amp;ldquo;hello, world&amp;rdquo;. The write to a happens before the receive on c, which happens before the corresponding send on c completes, which happens before the print.
If the channel were buffered (e.g., &lt;code&gt;c = make(chan int, 1)&lt;/code&gt;) then the program would not be guaranteed to print &amp;ldquo;hello, world&amp;rdquo;. (It might print the empty string, crash, or do something else.)&lt;/p&gt;

&lt;h2 id=&#34;concurrency:29d085475296ad0ae0e08e9c74a587d0&#34;&gt;Concurrency&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://talks.golang.org/2012/concurrency.slide&#34;&gt;Go Concurrency Patterns&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;main-exits:29d085475296ad0ae0e08e9c74a587d0&#34;&gt;&lt;code&gt;main&lt;/code&gt; exits&lt;/h3&gt;

&lt;p&gt;What happens to goroutines that running background when main function returns?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;When the main returns, the programm goes away.
       &amp;ndash; &lt;a href=&#34;https://youtu.be/f6kdp27TYZs?t=7m46s&#34;&gt;Rob Pike#main_exit&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It confused me for a long time, now I get a concrete answer.&lt;/p&gt;

&lt;h3 id=&#34;generator-in-go:29d085475296ad0ae0e08e9c74a587d0&#34;&gt;Generator in Go&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Generator: function that returns a channel.
Channels are first-class values, just like strings or integers.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;
import &amp;quot;time&amp;quot;
import &amp;quot;math/rand&amp;quot;

func main() {
    // Python-like usage
    for s := range boring(&amp;quot;generator&amp;quot;) {
        fmt.Println(s)
    }

    fmt.Println(&amp;quot;func main exits&amp;quot;)
}

// ### Generator ###
func boring(msg string) &amp;lt;-chan string { // Returns receive-only channel of strings.
    c := make(chan string)
    go func() { // We launch the goroutine from inside the function.
        for i := 0; i &amp;lt; 10; i++ {
            c &amp;lt;- fmt.Sprintf(&amp;quot;%s %d&amp;quot;, msg, i)
            time.Sleep(time.Duration(rand.Intn(1e3)) * time.Millisecond)
        }
        close(c) // close channel c, otherwise for-range will be blocked.
    }()
    return c // Return the channel to the caller.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unlike &lt;strong&gt;Generator&lt;/strong&gt; in Python, the concept in Go is simple: &lt;em&gt;Generator: function that returns a channel&lt;/em&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Python Generator: generates data in time.&lt;/li&gt;
&lt;li&gt;Go Generator: return a channel, reveives data in time.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;tricky-keyword-select:29d085475296ad0ae0e08e9c74a587d0&#34;&gt;Tricky Keyword, &lt;code&gt;select&lt;/code&gt;&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;Select&lt;/p&gt;

&lt;p&gt;The select statement provides another way to handle multiple channels.
It&amp;rsquo;s like a switch, but each case is a communication:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;All channels are evaluated.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Selection blocks until one communication can proceed, which then does.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If multiple can proceed, select chooses pseudo-randomly.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A default clause, if present, executes immediately if no channel is ready.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;select {
    case v1 := &amp;lt;-c1:
        fmt.Printf(&amp;quot;received %v from c1\n&amp;quot;, v1)
    case v2 := &amp;lt;-c2:
        fmt.Printf(&amp;quot;received %v from c2\n&amp;quot;, v1)
    case c3 &amp;lt;- 23:
        fmt.Printf(&amp;quot;sent %v to c3\n&amp;quot;, 23)
    default:
        fmt.Printf(&amp;quot;no one was ready to communicate\n&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Select with &lt;strong&gt;default&lt;/strong&gt; is a non-blocking statement, even if no other case can be processed. Without &lt;strong&gt;default&lt;/strong&gt;, select block forever if no other case can be processed.&lt;/p&gt;

&lt;p&gt;END.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>